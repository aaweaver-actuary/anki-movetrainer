(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined'
    ? factory(exports, require('chessboardjs/dist/chessboard-1.0.0.min.css'))
    : typeof define === 'function' && define.amd
      ? define(
          ['exports', 'chessboardjs/dist/chessboard-1.0.0.min.css'],
          factory,
        )
      : ((global =
          typeof globalThis !== 'undefined' ? globalThis : global || self),
        factory((global.AnkiMoveTrainer = {})));
})(this, function (exports) {
  'use strict';

  // @generated by Peggy 4.2.0.
  //
  // https://peggyjs.org/

  function rootNode(comment) {
    return comment !== null ? { comment, variations: [] } : { variations: [] };
  }

  function node(move, suffix, nag, comment, variations) {
    const node = { move, variations };

    if (suffix) {
      node.suffix = suffix;
    }

    if (nag) {
      node.nag = nag;
    }

    if (comment !== null) {
      node.comment = comment;
    }

    return node;
  }

  function lineToTree(...nodes) {
    const [root, ...rest] = nodes;

    let parent = root;

    for (const child of rest) {
      if (child !== null) {
        parent.variations = [child, ...child.variations];
        child.variations = [];
        parent = child;
      }
    }

    return root;
  }

  function pgn(headers, game) {
    if (game.marker && game.marker.comment) {
      let node = game.root;
      while (true) {
        const next = node.variations[0];
        if (!next) {
          node.comment = game.marker.comment;
          break;
        }
        node = next;
      }
    }

    return {
      headers,
      root: game.root,
      result: (game.marker && game.marker.result) ?? undefined,
    };
  }

  function peg$subclass(child, parent) {
    function C() {
      this.constructor = child;
    }
    C.prototype = parent.prototype;
    child.prototype = new C();
  }

  function peg$SyntaxError(message, expected, found, location) {
    var self = Error.call(this, message);
    // istanbul ignore next Check is a necessary evil to support older environments
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(self, peg$SyntaxError.prototype);
    }
    self.expected = expected;
    self.found = found;
    self.location = location;
    self.name = 'SyntaxError';
    return self;
  }

  peg$subclass(peg$SyntaxError, Error);

  function peg$padEnd(str, targetLength, padString) {
    padString = padString || ' ';
    if (str.length > targetLength) {
      return str;
    }
    targetLength -= str.length;
    padString += padString.repeat(targetLength);
    return str + padString.slice(0, targetLength);
  }

  peg$SyntaxError.prototype.format = function (sources) {
    var str = 'Error: ' + this.message;
    if (this.location) {
      var src = null;
      var k;
      for (k = 0; k < sources.length; k++) {
        if (sources[k].source === this.location.source) {
          src = sources[k].text.split(/\r\n|\n|\r/g);
          break;
        }
      }
      var s = this.location.start;
      var offset_s =
        this.location.source &&
        typeof this.location.source.offset === 'function'
          ? this.location.source.offset(s)
          : s;
      var loc =
        this.location.source + ':' + offset_s.line + ':' + offset_s.column;
      if (src) {
        var e = this.location.end;
        var filler = peg$padEnd('', offset_s.line.toString().length, ' ');
        var line = src[s.line - 1];
        var last = s.line === e.line ? e.column : line.length + 1;
        var hatLen = last - s.column || 1;
        str +=
          '\n --> ' +
          loc +
          '\n' +
          filler +
          ' |\n' +
          offset_s.line +
          ' | ' +
          line +
          '\n' +
          filler +
          ' | ' +
          peg$padEnd('', s.column - 1, ' ') +
          peg$padEnd('', hatLen, '^');
      } else {
        str += '\n at ' + loc;
      }
    }
    return str;
  };

  peg$SyntaxError.buildMessage = function (expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
      literal: function (expectation) {
        return '"' + literalEscape(expectation.text) + '"';
      },

      class: function (expectation) {
        var escapedParts = expectation.parts.map(function (part) {
          return Array.isArray(part)
            ? classEscape(part[0]) + '-' + classEscape(part[1])
            : classEscape(part);
        });

        return (
          '[' + (expectation.inverted ? '^' : '') + escapedParts.join('') + ']'
        );
      },

      any: function () {
        return 'any character';
      },

      end: function () {
        return 'end of input';
      },

      other: function (expectation) {
        return expectation.description;
      },
    };

    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }

    function literalEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/"/g, '\\"')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
    }

    function classEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/\]/g, '\\]')
        .replace(/\^/g, '\\^')
        .replace(/-/g, '\\-')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
    }

    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }

    function describeExpected(expected) {
      var descriptions = expected.map(describeExpectation);
      var i, j;

      descriptions.sort();

      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }

      switch (descriptions.length) {
        case 1:
          return descriptions[0];

        case 2:
          return descriptions[0] + ' or ' + descriptions[1];

        default:
          return (
            descriptions.slice(0, -1).join(', ') +
            ', or ' +
            descriptions[descriptions.length - 1]
          );
      }
    }

    function describeFound(found) {
      return found ? '"' + literalEscape(found) + '"' : 'end of input';
    }

    return (
      'Expected ' +
      describeExpected(expected) +
      ' but ' +
      describeFound(found) +
      ' found.'
    );
  };

  function peg$parse(input, options) {
    options = options !== undefined ? options : {};

    var peg$FAILED = {};
    var peg$source = options.grammarSource;

    var peg$startRuleFunctions = { pgn: peg$parsepgn };
    var peg$startRuleFunction = peg$parsepgn;

    var peg$c0 = '[';
    var peg$c1 = '"';
    var peg$c2 = ']';
    var peg$c3 = '.';
    var peg$c4 = 'O-O-O';
    var peg$c5 = 'O-O';
    var peg$c6 = '0-0-0';
    var peg$c7 = '0-0';
    var peg$c8 = '$';
    var peg$c9 = '{';
    var peg$c10 = '}';
    var peg$c11 = ';';
    var peg$c12 = '(';
    var peg$c13 = ')';
    var peg$c14 = '1-0';
    var peg$c15 = '0-1';
    var peg$c16 = '1/2-1/2';
    var peg$c17 = '*';

    var peg$r0 = /^[a-zA-Z]/;
    var peg$r1 = /^[^"]/;
    var peg$r2 = /^[0-9]/;
    var peg$r3 = /^[.]/;
    var peg$r4 = /^[a-zA-Z1-8\-=]/;
    var peg$r5 = /^[+#]/;
    var peg$r6 = /^[!?]/;
    var peg$r7 = /^[^}]/;
    var peg$r8 = /^[^\r\n]/;
    var peg$r9 = /^[ \t\r\n]/;

    var peg$e0 = peg$otherExpectation('tag pair');
    var peg$e1 = peg$literalExpectation('[', false);
    var peg$e2 = peg$literalExpectation('"', false);
    var peg$e3 = peg$literalExpectation(']', false);
    var peg$e4 = peg$otherExpectation('tag name');
    var peg$e5 = peg$classExpectation(
      [
        ['a', 'z'],
        ['A', 'Z'],
      ],
      false,
      false,
    );
    var peg$e6 = peg$otherExpectation('tag value');
    var peg$e7 = peg$classExpectation(['"'], true, false);
    var peg$e8 = peg$otherExpectation('move number');
    var peg$e9 = peg$classExpectation([['0', '9']], false, false);
    var peg$e10 = peg$literalExpectation('.', false);
    var peg$e11 = peg$classExpectation(['.'], false, false);
    var peg$e12 = peg$otherExpectation('standard algebraic notation');
    var peg$e13 = peg$literalExpectation('O-O-O', false);
    var peg$e14 = peg$literalExpectation('O-O', false);
    var peg$e15 = peg$literalExpectation('0-0-0', false);
    var peg$e16 = peg$literalExpectation('0-0', false);
    var peg$e17 = peg$classExpectation(
      [['a', 'z'], ['A', 'Z'], ['1', '8'], '-', '='],
      false,
      false,
    );
    var peg$e18 = peg$classExpectation(['+', '#'], false, false);
    var peg$e19 = peg$otherExpectation('suffix annotation');
    var peg$e20 = peg$classExpectation(['!', '?'], false, false);
    var peg$e21 = peg$otherExpectation('NAG');
    var peg$e22 = peg$literalExpectation('$', false);
    var peg$e23 = peg$otherExpectation('brace comment');
    var peg$e24 = peg$literalExpectation('{', false);
    var peg$e25 = peg$classExpectation(['}'], true, false);
    var peg$e26 = peg$literalExpectation('}', false);
    var peg$e27 = peg$otherExpectation('rest of line comment');
    var peg$e28 = peg$literalExpectation(';', false);
    var peg$e29 = peg$classExpectation(['\r', '\n'], true, false);
    var peg$e30 = peg$otherExpectation('variation');
    var peg$e31 = peg$literalExpectation('(', false);
    var peg$e32 = peg$literalExpectation(')', false);
    var peg$e33 = peg$otherExpectation('game termination marker');
    var peg$e34 = peg$literalExpectation('1-0', false);
    var peg$e35 = peg$literalExpectation('0-1', false);
    var peg$e36 = peg$literalExpectation('1/2-1/2', false);
    var peg$e37 = peg$literalExpectation('*', false);
    var peg$e38 = peg$otherExpectation('whitespace');
    var peg$e39 = peg$classExpectation([' ', '\t', '\r', '\n'], false, false);

    var peg$f0 = function (headers, game) {
      return pgn(headers, game);
    };
    var peg$f1 = function (tagPairs) {
      return Object.fromEntries(tagPairs);
    };
    var peg$f2 = function (tagName, tagValue) {
      return [tagName, tagValue];
    };
    var peg$f3 = function (root, marker) {
      return { root, marker };
    };
    var peg$f4 = function (comment, moves) {
      return lineToTree(rootNode(comment), ...moves.flat());
    };
    var peg$f5 = function (san, suffix, nag, comment, variations) {
      return node(san, suffix, nag, comment, variations);
    };
    var peg$f6 = function (nag) {
      return nag;
    };
    var peg$f7 = function (comment) {
      return comment.replace(/[\r\n]+/g, ' ');
    };
    var peg$f8 = function (comment) {
      return comment.trim();
    };
    var peg$f9 = function (line) {
      return line;
    };
    var peg$f10 = function (result, comment) {
      return { result, comment };
    };
    var peg$currPos = options.peg$currPos | 0;
    var peg$posDetailsCache = [{ line: 1, column: 1 }];
    var peg$maxFailPos = peg$currPos;
    var peg$maxFailExpected = options.peg$maxFailExpected || [];
    var peg$silentFails = options.peg$silentFails | 0;

    var peg$result;

    if (options.startRule) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error(
          'Can\'t start parsing from rule "' + options.startRule + '".',
        );
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function peg$literalExpectation(text, ignoreCase) {
      return { type: 'literal', text: text, ignoreCase: ignoreCase };
    }

    function peg$classExpectation(parts, inverted, ignoreCase) {
      return {
        type: 'class',
        parts: parts,
        inverted: inverted,
        ignoreCase: ignoreCase,
      };
    }

    function peg$endExpectation() {
      return { type: 'end' };
    }

    function peg$otherExpectation(description) {
      return { type: 'other', description: description };
    }

    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos];
      var p;

      if (details) {
        return details;
      } else {
        if (pos >= peg$posDetailsCache.length) {
          p = peg$posDetailsCache.length - 1;
        } else {
          p = pos;
          while (!peg$posDetailsCache[--p]) {}
        }

        details = peg$posDetailsCache[p];
        details = {
          line: details.line,
          column: details.column,
        };

        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }

          p++;
        }

        peg$posDetailsCache[pos] = details;

        return details;
      }
    }

    function peg$computeLocation(startPos, endPos, offset) {
      var startPosDetails = peg$computePosDetails(startPos);
      var endPosDetails = peg$computePosDetails(endPos);

      var res = {
        source: peg$source,
        start: {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column,
        },
        end: {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column,
        },
      };
      return res;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) {
        return;
      }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildStructuredError(expected, found, location) {
      return new peg$SyntaxError(
        peg$SyntaxError.buildMessage(expected, found),
        expected,
        found,
        location,
      );
    }

    function peg$parsepgn() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parsetagPairSection();
      s2 = peg$parsemoveTextSection();
      s0 = peg$f0(s1, s2);

      return s0;
    }

    function peg$parsetagPairSection() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsetagPair();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsetagPair();
      }
      s2 = peg$parse_();
      s0 = peg$f1(s1);

      return s0;
    }

    function peg$parsetagPair() {
      var s0, s2, s4, s6, s7, s8, s10;

      peg$silentFails++;
      s0 = peg$currPos;
      peg$parse_();
      if (input.charCodeAt(peg$currPos) === 91) {
        s2 = peg$c0;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e1);
        }
      }
      if (s2 !== peg$FAILED) {
        peg$parse_();
        s4 = peg$parsetagName();
        if (s4 !== peg$FAILED) {
          peg$parse_();
          if (input.charCodeAt(peg$currPos) === 34) {
            s6 = peg$c1;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s6 !== peg$FAILED) {
            s7 = peg$parsetagValue();
            if (input.charCodeAt(peg$currPos) === 34) {
              s8 = peg$c1;
              peg$currPos++;
            } else {
              s8 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e2);
              }
            }
            if (s8 !== peg$FAILED) {
              peg$parse_();
              if (input.charCodeAt(peg$currPos) === 93) {
                s10 = peg$c2;
                peg$currPos++;
              } else {
                s10 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              if (s10 !== peg$FAILED) {
                s0 = peg$f2(s4, s7);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        if (peg$silentFails === 0) {
          peg$fail(peg$e0);
        }
      }

      return s0;
    }

    function peg$parsetagName() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      s2 = input.charAt(peg$currPos);
      if (peg$r0.test(s2)) {
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e5);
        }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = input.charAt(peg$currPos);
          if (peg$r0.test(s2)) {
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e4);
        }
      }

      return s0;
    }

    function peg$parsetagValue() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      s2 = input.charAt(peg$currPos);
      if (peg$r1.test(s2)) {
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e7);
        }
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = input.charAt(peg$currPos);
        if (peg$r1.test(s2)) {
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
      }
      s0 = input.substring(s0, peg$currPos);
      peg$silentFails--;
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e6);
      }

      return s0;
    }

    function peg$parsemoveTextSection() {
      var s0, s1, s3;

      s0 = peg$currPos;
      s1 = peg$parseline();
      peg$parse_();
      s3 = peg$parsegameTerminationMarker();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      peg$parse_();
      s0 = peg$f3(s1, s3);

      return s0;
    }

    function peg$parseline() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsecomment();
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      s2 = [];
      s3 = peg$parsemove();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parsemove();
      }
      s0 = peg$f4(s1, s2);

      return s0;
    }

    function peg$parsemove() {
      var s0, s4, s5, s6, s7, s8, s9, s10;

      s0 = peg$currPos;
      peg$parse_();
      peg$parsemoveNumber();
      peg$parse_();
      s4 = peg$parsesan();
      if (s4 !== peg$FAILED) {
        s5 = peg$parsesuffixAnnotation();
        if (s5 === peg$FAILED) {
          s5 = null;
        }
        s6 = [];
        s7 = peg$parsenag();
        while (s7 !== peg$FAILED) {
          s6.push(s7);
          s7 = peg$parsenag();
        }
        s7 = peg$parse_();
        s8 = peg$parsecomment();
        if (s8 === peg$FAILED) {
          s8 = null;
        }
        s9 = [];
        s10 = peg$parsevariation();
        while (s10 !== peg$FAILED) {
          s9.push(s10);
          s10 = peg$parsevariation();
        }
        s0 = peg$f5(s4, s5, s6, s8, s9);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsemoveNumber() {
      var s0, s1, s2, s3, s4, s5;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      s2 = input.charAt(peg$currPos);
      if (peg$r2.test(s2)) {
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e9);
        }
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = input.charAt(peg$currPos);
        if (peg$r2.test(s2)) {
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
      }
      if (input.charCodeAt(peg$currPos) === 46) {
        s2 = peg$c3;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e10);
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        s4 = [];
        s5 = input.charAt(peg$currPos);
        if (peg$r3.test(s5)) {
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e11);
          }
        }
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          s5 = input.charAt(peg$currPos);
          if (peg$r3.test(s5)) {
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e11);
            }
          }
        }
        s1 = [s1, s2, s3, s4];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e8);
        }
      }

      return s0;
    }

    function peg$parsesan() {
      var s0, s1, s2, s3, s4, s5;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c4) {
        s2 = peg$c4;
        peg$currPos += 5;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e13);
        }
      }
      if (s2 === peg$FAILED) {
        if (input.substr(peg$currPos, 3) === peg$c5) {
          s2 = peg$c5;
          peg$currPos += 3;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e14);
          }
        }
        if (s2 === peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c6) {
            s2 = peg$c6;
            peg$currPos += 5;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e15);
            }
          }
          if (s2 === peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c7) {
              s2 = peg$c7;
              peg$currPos += 3;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e16);
              }
            }
            if (s2 === peg$FAILED) {
              s2 = peg$currPos;
              s3 = input.charAt(peg$currPos);
              if (peg$r0.test(s3)) {
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e5);
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = input.charAt(peg$currPos);
                if (peg$r4.test(s5)) {
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e17);
                  }
                }
                if (s5 !== peg$FAILED) {
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = input.charAt(peg$currPos);
                    if (peg$r4.test(s5)) {
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e17);
                      }
                    }
                  }
                } else {
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  s3 = [s3, s4];
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            }
          }
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = input.charAt(peg$currPos);
        if (peg$r5.test(s3)) {
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e18);
          }
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e12);
        }
      }

      return s0;
    }

    function peg$parsesuffixAnnotation() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      s2 = input.charAt(peg$currPos);
      if (peg$r6.test(s2)) {
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e20);
        }
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (s1.length >= 2) {
          s2 = peg$FAILED;
        } else {
          s2 = input.charAt(peg$currPos);
          if (peg$r6.test(s2)) {
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
        }
      }
      if (s1.length < 1) {
        peg$currPos = s0;
        s0 = peg$FAILED;
      } else {
        s0 = s1;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e19);
        }
      }

      return s0;
    }

    function peg$parsenag() {
      var s0, s2, s3, s4, s5;

      peg$silentFails++;
      s0 = peg$currPos;
      peg$parse_();
      if (input.charCodeAt(peg$currPos) === 36) {
        s2 = peg$c8;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e22);
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = [];
        s5 = input.charAt(peg$currPos);
        if (peg$r2.test(s5)) {
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        if (s5 !== peg$FAILED) {
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = input.charAt(peg$currPos);
            if (peg$r2.test(s5)) {
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e9);
              }
            }
          }
        } else {
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s3 = input.substring(s3, peg$currPos);
        } else {
          s3 = s4;
        }
        if (s3 !== peg$FAILED) {
          s0 = peg$f6(s3);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        if (peg$silentFails === 0) {
          peg$fail(peg$e21);
        }
      }

      return s0;
    }

    function peg$parsecomment() {
      var s0;

      s0 = peg$parsebraceComment();
      if (s0 === peg$FAILED) {
        s0 = peg$parserestOfLineComment();
      }

      return s0;
    }

    function peg$parsebraceComment() {
      var s0, s1, s2, s3, s4;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s1 = peg$c9;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e24);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = [];
        s4 = input.charAt(peg$currPos);
        if (peg$r7.test(s4)) {
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e25);
          }
        }
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = input.charAt(peg$currPos);
          if (peg$r7.test(s4)) {
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e25);
            }
          }
        }
        s2 = input.substring(s2, peg$currPos);
        if (input.charCodeAt(peg$currPos) === 125) {
          s3 = peg$c10;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e26);
          }
        }
        if (s3 !== peg$FAILED) {
          s0 = peg$f7(s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e23);
        }
      }

      return s0;
    }

    function peg$parserestOfLineComment() {
      var s0, s1, s2, s3, s4;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 59) {
        s1 = peg$c11;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e28);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = [];
        s4 = input.charAt(peg$currPos);
        if (peg$r8.test(s4)) {
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e29);
          }
        }
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = input.charAt(peg$currPos);
          if (peg$r8.test(s4)) {
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e29);
            }
          }
        }
        s2 = input.substring(s2, peg$currPos);
        s0 = peg$f8(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e27);
        }
      }

      return s0;
    }

    function peg$parsevariation() {
      var s0, s2, s3, s5;

      peg$silentFails++;
      s0 = peg$currPos;
      peg$parse_();
      if (input.charCodeAt(peg$currPos) === 40) {
        s2 = peg$c12;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e31);
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseline();
        if (s3 !== peg$FAILED) {
          peg$parse_();
          if (input.charCodeAt(peg$currPos) === 41) {
            s5 = peg$c13;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e32);
            }
          }
          if (s5 !== peg$FAILED) {
            s0 = peg$f9(s3);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        if (peg$silentFails === 0) {
          peg$fail(peg$e30);
        }
      }

      return s0;
    }

    function peg$parsegameTerminationMarker() {
      var s0, s1, s3;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c14) {
        s1 = peg$c14;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e34);
        }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 3) === peg$c15) {
          s1 = peg$c15;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e35);
          }
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 7) === peg$c16) {
            s1 = peg$c16;
            peg$currPos += 7;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e36);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 42) {
              s1 = peg$c17;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e37);
              }
            }
          }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$parse_();
        s3 = peg$parsecomment();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        s0 = peg$f10(s1, s3);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e33);
        }
      }

      return s0;
    }

    function peg$parse_() {
      var s0, s1;

      peg$silentFails++;
      s0 = [];
      s1 = input.charAt(peg$currPos);
      if (peg$r9.test(s1)) {
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$e39);
        }
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = input.charAt(peg$currPos);
        if (peg$r9.test(s1)) {
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e39);
          }
        }
      }
      peg$silentFails--;
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$e38);
      }

      return s0;
    }

    peg$result = peg$startRuleFunction();

    if (options.peg$library) {
      return /** @type {any} */ ({
        peg$result,
        peg$currPos,
        peg$FAILED,
        peg$maxFailExpected,
        peg$maxFailPos,
      });
    }
    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }

      throw peg$buildStructuredError(
        peg$maxFailExpected,
        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input.length
          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos),
      );
    }
  }

  /**
   * @license
   * Copyright (c) 2025, Jeff Hlywa (jhlywa@gmail.com)
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   *    this list of conditions and the following disclaimer.
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   *    this list of conditions and the following disclaimer in the documentation
   *    and/or other materials provided with the distribution.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  const MASK64 = 0xffffffffffffffffn;
  function rotl(x, k) {
    return ((x << k) | (x >> (64n - k))) & 0xffffffffffffffffn;
  }
  function wrappingMul(x, y) {
    return (x * y) & MASK64;
  }
  // xoroshiro128**
  function xoroshiro128(state) {
    return function () {
      let s0 = BigInt(state & MASK64);
      let s1 = BigInt((state >> 64n) & MASK64);
      const result = wrappingMul(rotl(wrappingMul(s0, 5n), 7n), 9n);
      s1 ^= s0;
      s0 = (rotl(s0, 24n) ^ s1 ^ (s1 << 16n)) & MASK64;
      s1 = rotl(s1, 37n);
      state = (s1 << 64n) | s0;
      return result;
    };
  }
  const rand = xoroshiro128(0xa187eb39cdcaed8f31c4b365b102e01en);
  const PIECE_KEYS = Array.from({ length: 2 }, () =>
    Array.from({ length: 6 }, () => Array.from({ length: 128 }, () => rand())),
  );
  const EP_KEYS = Array.from({ length: 8 }, () => rand());
  const CASTLING_KEYS = Array.from({ length: 16 }, () => rand());
  const SIDE_KEY = rand();
  const WHITE = 'w';
  const BLACK = 'b';
  const PAWN = 'p';
  const KNIGHT = 'n';
  const BISHOP = 'b';
  const ROOK = 'r';
  const QUEEN = 'q';
  const KING = 'k';
  const DEFAULT_POSITION =
    'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
  class Move {
    color;
    from;
    to;
    piece;
    captured;
    promotion;
    /**
     * @deprecated This field is deprecated and will be removed in version 2.0.0.
     * Please use move descriptor functions instead: `isCapture`, `isPromotion`,
     * `isEnPassant`, `isKingsideCastle`, `isQueensideCastle`, `isCastle`, and
     * `isBigPawn`
     */
    flags;
    san;
    lan;
    before;
    after;
    constructor(chess, internal) {
      const { color, piece, from, to, flags, captured, promotion } = internal;
      const fromAlgebraic = algebraic(from);
      const toAlgebraic = algebraic(to);
      this.color = color;
      this.piece = piece;
      this.from = fromAlgebraic;
      this.to = toAlgebraic;
      /*
       * HACK: The chess['_method']() calls below invoke private methods in the
       * Chess class to generate SAN and FEN. It's a bit of a hack, but makes the
       * code cleaner elsewhere.
       */
      this.san = chess['_moveToSan'](
        internal,
        chess['_moves']({ legal: true }),
      );
      this.lan = fromAlgebraic + toAlgebraic;
      this.before = chess.fen();
      // Generate the FEN for the 'after' key
      chess['_makeMove'](internal);
      this.after = chess.fen();
      chess['_undoMove']();
      // Build the text representation of the move flags
      this.flags = '';
      for (const flag in BITS) {
        if (BITS[flag] & flags) {
          this.flags += FLAGS[flag];
        }
      }
      if (captured) {
        this.captured = captured;
      }
      if (promotion) {
        this.promotion = promotion;
        this.lan += promotion;
      }
    }
    isCapture() {
      return this.flags.indexOf(FLAGS['CAPTURE']) > -1;
    }
    isPromotion() {
      return this.flags.indexOf(FLAGS['PROMOTION']) > -1;
    }
    isEnPassant() {
      return this.flags.indexOf(FLAGS['EP_CAPTURE']) > -1;
    }
    isKingsideCastle() {
      return this.flags.indexOf(FLAGS['KSIDE_CASTLE']) > -1;
    }
    isQueensideCastle() {
      return this.flags.indexOf(FLAGS['QSIDE_CASTLE']) > -1;
    }
    isBigPawn() {
      return this.flags.indexOf(FLAGS['BIG_PAWN']) > -1;
    }
  }
  const EMPTY = -1;
  const FLAGS = {
    NORMAL: 'n',
    CAPTURE: 'c',
    BIG_PAWN: 'b',
    EP_CAPTURE: 'e',
    PROMOTION: 'p',
    KSIDE_CASTLE: 'k',
    QSIDE_CASTLE: 'q',
    NULL_MOVE: '-',
  };
  const BITS = {
    NORMAL: 1,
    CAPTURE: 2,
    BIG_PAWN: 4,
    EP_CAPTURE: 8,
    PROMOTION: 16,
    KSIDE_CASTLE: 32,
    QSIDE_CASTLE: 64,
    NULL_MOVE: 128,
  };
  /* eslint-disable @typescript-eslint/naming-convention */
  // these are required, according to spec
  const SEVEN_TAG_ROSTER = {
    Event: '?',
    Site: '?',
    Date: '????.??.??',
    Round: '?',
    White: '?',
    Black: '?',
    Result: '*',
  };
  /**
   * These nulls are placeholders to fix the order of tags (as they appear in PGN spec); null values will be
   * eliminated in getHeaders()
   */
  const SUPLEMENTAL_TAGS = {
    WhiteTitle: null,
    BlackTitle: null,
    WhiteElo: null,
    BlackElo: null,
    WhiteUSCF: null,
    BlackUSCF: null,
    WhiteNA: null,
    BlackNA: null,
    WhiteType: null,
    BlackType: null,
    EventDate: null,
    EventSponsor: null,
    Section: null,
    Stage: null,
    Board: null,
    Opening: null,
    Variation: null,
    SubVariation: null,
    ECO: null,
    NIC: null,
    Time: null,
    UTCTime: null,
    UTCDate: null,
    TimeControl: null,
    SetUp: null,
    FEN: null,
    Termination: null,
    Annotator: null,
    Mode: null,
    PlyCount: null,
  };
  const HEADER_TEMPLATE = {
    ...SEVEN_TAG_ROSTER,
    ...SUPLEMENTAL_TAGS,
  };
  /* eslint-enable @typescript-eslint/naming-convention */
  /*
   * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM
   * ----------------------------------------------------------------------------
   * From https://github.com/jhlywa/chess.js/issues/230
   *
   * A lot of people are confused when they first see the internal representation
   * of chess.js. It uses the 0x88 Move Generation Algorithm which internally
   * stores the board as an 8x16 array. This is purely for efficiency but has a
   * couple of interesting benefits:
   *
   * 1. 0x88 offers a very inexpensive "off the board" check. Bitwise AND (&) any
   *    square with 0x88, if the result is non-zero then the square is off the
   *    board. For example, assuming a knight square A8 (0 in 0x88 notation),
   *    there are 8 possible directions in which the knight can move. These
   *    directions are relative to the 8x16 board and are stored in the
   *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two
   *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88
   *    (because of two-complement representation of -18). The non-zero result
   *    means the square is off the board and the move is illegal. Take the
   *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero
   *    means the square is on the board.
   *
   * 2. The relative distance (or difference) between two squares on a 8x16 board
   *    is unique and can be used to inexpensively determine if a piece on a
   *    square can attack any other arbitrary square. For example, let's see if a
   *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is
   *    -80. We add 119 to make the ATTACKS array index non-negative (because the
   *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a
   *    bitmask of pieces that can attack from that distance and direction.
   *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the
   *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn
   *    example, we would check to see if 24 & 0x1 is non-zero, which it is
   *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a
   *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that
   *    there are no blocking pieces between E7 and E2. That's where the RAYS
   *    array comes in. It provides an offset (in this case 16) to add to E7 (20)
   *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.
   */
  // prettier-ignore
  // eslint-disable-next-line
  const Ox88 = {
      a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7,
      a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23,
      a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39,
      a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55,
      a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71,
      a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87,
      a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103,
      a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119
  };
  const PAWN_OFFSETS = {
    b: [16, 32, 17, 15],
    w: [-16, -32, -17, -15],
  };
  const PIECE_OFFSETS = {
    n: [-18, -33, -31, -14, 18, 33, 31, 14],
    b: [-17, -15, 17, 15],
    r: [-16, 1, 16, -1],
    q: [-17, -16, -15, 1, 17, 16, 15, -1],
    k: [-17, -16, -15, 1, 17, 16, 15, -1],
  };
  // prettier-ignore
  const ATTACKS = [
      20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0,
      0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,
      0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,
      0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,
      0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,
      24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0,
      0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,
      0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,
      0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,
      0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,
      20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20
  ];
  // prettier-ignore
  const RAYS = [
      17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0,
      0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0,
      0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0,
      0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0,
      0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0,
      1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0,
      0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0,
      0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0,
      0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0,
      0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0,
      -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17
  ];
  const PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 };
  const SYMBOLS = 'pnbrqkPNBRQK';
  const PROMOTIONS = [KNIGHT, BISHOP, ROOK, QUEEN];
  const RANK_1 = 7;
  const RANK_2 = 6;
  /*
   * const RANK_3 = 5
   * const RANK_4 = 4
   * const RANK_5 = 3
   * const RANK_6 = 2
   */
  const RANK_7 = 1;
  const RANK_8 = 0;
  const SIDES = {
    [KING]: BITS.KSIDE_CASTLE,
    [QUEEN]: BITS.QSIDE_CASTLE,
  };
  const ROOKS = {
    w: [
      { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },
      { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },
    ],
    b: [
      { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },
      { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },
    ],
  };
  const SECOND_RANK = { b: RANK_7, w: RANK_2 };
  const SAN_NULLMOVE = '--';
  // Extracts the zero-based rank of an 0x88 square.
  function rank(square) {
    return square >> 4;
  }
  // Extracts the zero-based file of an 0x88 square.
  function file(square) {
    return square & 0xf;
  }
  function isDigit(c) {
    return '0123456789'.indexOf(c) !== -1;
  }
  // Converts a 0x88 square to algebraic notation.
  function algebraic(square) {
    const f = file(square);
    const r = rank(square);
    return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1);
  }
  function swapColor(color) {
    return color === WHITE ? BLACK : WHITE;
  }
  function validateFen(fen) {
    // 1st criterion: 6 space-seperated fields?
    const tokens = fen.split(/\s+/);
    if (tokens.length !== 6) {
      return {
        ok: false,
        error: 'Invalid FEN: must contain six space-delimited fields',
      };
    }
    // 2nd criterion: move number field is a integer value > 0?
    const moveNumber = parseInt(tokens[5], 10);
    if (isNaN(moveNumber) || moveNumber <= 0) {
      return {
        ok: false,
        error: 'Invalid FEN: move number must be a positive integer',
      };
    }
    // 3rd criterion: half move counter is an integer >= 0?
    const halfMoves = parseInt(tokens[4], 10);
    if (isNaN(halfMoves) || halfMoves < 0) {
      return {
        ok: false,
        error:
          'Invalid FEN: half move counter number must be a non-negative integer',
      };
    }
    // 4th criterion: 4th field is a valid e.p.-string?
    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {
      return { ok: false, error: 'Invalid FEN: en-passant square is invalid' };
    }
    // 5th criterion: 3th field is a valid castle-string?
    if (/[^kKqQ-]/.test(tokens[2])) {
      return {
        ok: false,
        error: 'Invalid FEN: castling availability is invalid',
      };
    }
    // 6th criterion: 2nd field is "w" (white) or "b" (black)?
    if (!/^(w|b)$/.test(tokens[1])) {
      return { ok: false, error: 'Invalid FEN: side-to-move is invalid' };
    }
    // 7th criterion: 1st field contains 8 rows?
    const rows = tokens[0].split('/');
    if (rows.length !== 8) {
      return {
        ok: false,
        error: "Invalid FEN: piece data does not contain 8 '/'-delimited rows",
      };
    }
    // 8th criterion: every row is valid?
    for (let i = 0; i < rows.length; i++) {
      // check for right sum of fields AND not two numbers in succession
      let sumFields = 0;
      let previousWasNumber = false;
      for (let k = 0; k < rows[i].length; k++) {
        if (isDigit(rows[i][k])) {
          if (previousWasNumber) {
            return {
              ok: false,
              error: 'Invalid FEN: piece data is invalid (consecutive number)',
            };
          }
          sumFields += parseInt(rows[i][k], 10);
          previousWasNumber = true;
        } else {
          if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {
            return {
              ok: false,
              error: 'Invalid FEN: piece data is invalid (invalid piece)',
            };
          }
          sumFields += 1;
          previousWasNumber = false;
        }
      }
      if (sumFields !== 8) {
        return {
          ok: false,
          error:
            'Invalid FEN: piece data is invalid (too many squares in rank)',
        };
      }
    }
    // 9th criterion: is en-passant square legal?
    if (
      (tokens[3][1] == '3' && tokens[1] == 'w') ||
      (tokens[3][1] == '6' && tokens[1] == 'b')
    ) {
      return { ok: false, error: 'Invalid FEN: illegal en-passant square' };
    }
    // 10th criterion: does chess position contain exact two kings?
    const kings = [
      { color: 'white', regex: /K/g },
      { color: 'black', regex: /k/g },
    ];
    for (const { color, regex } of kings) {
      if (!regex.test(tokens[0])) {
        return { ok: false, error: `Invalid FEN: missing ${color} king` };
      }
      if ((tokens[0].match(regex) || []).length > 1) {
        return { ok: false, error: `Invalid FEN: too many ${color} kings` };
      }
    }
    // 11th criterion: are any pawns on the first or eighth rows?
    if (
      Array.from(rows[0] + rows[7]).some((char) => char.toUpperCase() === 'P')
    ) {
      return {
        ok: false,
        error: 'Invalid FEN: some pawns are on the edge rows',
      };
    }
    return { ok: true };
  }
  // this function is used to uniquely identify ambiguous moves
  function getDisambiguator(move, moves) {
    const from = move.from;
    const to = move.to;
    const piece = move.piece;
    let ambiguities = 0;
    let sameRank = 0;
    let sameFile = 0;
    for (let i = 0, len = moves.length; i < len; i++) {
      const ambigFrom = moves[i].from;
      const ambigTo = moves[i].to;
      const ambigPiece = moves[i].piece;
      /*
       * if a move of the same piece type ends on the same to square, we'll need
       * to add a disambiguator to the algebraic notation
       */
      if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {
        ambiguities++;
        if (rank(from) === rank(ambigFrom)) {
          sameRank++;
        }
        if (file(from) === file(ambigFrom)) {
          sameFile++;
        }
      }
    }
    if (ambiguities > 0) {
      if (sameRank > 0 && sameFile > 0) {
        /*
         * if there exists a similar moving piece on the same rank and file as
         * the move in question, use the square as the disambiguator
         */
        return algebraic(from);
      } else if (sameFile > 0) {
        /*
         * if the moving piece rests on the same file, use the rank symbol as the
         * disambiguator
         */
        return algebraic(from).charAt(1);
      } else {
        // else use the file symbol
        return algebraic(from).charAt(0);
      }
    }
    return '';
  }
  function addMove(
    moves,
    color,
    from,
    to,
    piece,
    captured = undefined,
    flags = BITS.NORMAL,
  ) {
    const r = rank(to);
    if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {
      for (let i = 0; i < PROMOTIONS.length; i++) {
        const promotion = PROMOTIONS[i];
        moves.push({
          color,
          from,
          to,
          piece,
          captured,
          promotion,
          flags: flags | BITS.PROMOTION,
        });
      }
    } else {
      moves.push({
        color,
        from,
        to,
        piece,
        captured,
        flags,
      });
    }
  }
  function inferPieceType(san) {
    let pieceType = san.charAt(0);
    if (pieceType >= 'a' && pieceType <= 'h') {
      const matches = san.match(/[a-h]\d.*[a-h]\d/);
      if (matches) {
        return undefined;
      }
      return PAWN;
    }
    pieceType = pieceType.toLowerCase();
    if (pieceType === 'o') {
      return KING;
    }
    return pieceType;
  }
  // parses all of the decorators out of a SAN string
  function strippedSan(move) {
    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');
  }
  class Chess {
    _board = new Array(128);
    _turn = WHITE;
    _header = {};
    _kings = { w: EMPTY, b: EMPTY };
    _epSquare = -1;
    _halfMoves = 0;
    _moveNumber = 0;
    _history = [];
    _comments = {};
    _castling = { w: 0, b: 0 };
    _hash = 0n;
    // tracks number of times a position has been seen for repetition checking
    _positionCount = new Map();
    constructor(fen = DEFAULT_POSITION, { skipValidation = false } = {}) {
      this.load(fen, { skipValidation });
    }
    clear({ preserveHeaders = false } = {}) {
      this._board = new Array(128);
      this._kings = { w: EMPTY, b: EMPTY };
      this._turn = WHITE;
      this._castling = { w: 0, b: 0 };
      this._epSquare = EMPTY;
      this._halfMoves = 0;
      this._moveNumber = 1;
      this._history = [];
      this._comments = {};
      this._header = preserveHeaders ? this._header : { ...HEADER_TEMPLATE };
      this._hash = this._computeHash();
      this._positionCount = new Map();
      /*
       * Delete the SetUp and FEN headers (if preserved), the board is empty and
       * these headers don't make sense in this state. They'll get added later
       * via .load() or .put()
       */
      this._header['SetUp'] = null;
      this._header['FEN'] = null;
    }
    load(fen, { skipValidation = false, preserveHeaders = false } = {}) {
      let tokens = fen.split(/\s+/);
      // append commonly omitted fen tokens
      if (tokens.length >= 2 && tokens.length < 6) {
        const adjustments = ['-', '-', '0', '1'];
        fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ');
      }
      tokens = fen.split(/\s+/);
      if (!skipValidation) {
        const { ok, error } = validateFen(fen);
        if (!ok) {
          throw new Error(error);
        }
      }
      const position = tokens[0];
      let square = 0;
      this.clear({ preserveHeaders });
      for (let i = 0; i < position.length; i++) {
        const piece = position.charAt(i);
        if (piece === '/') {
          square += 8;
        } else if (isDigit(piece)) {
          square += parseInt(piece, 10);
        } else {
          const color = piece < 'a' ? WHITE : BLACK;
          this._put({ type: piece.toLowerCase(), color }, algebraic(square));
          square++;
        }
      }
      this._turn = tokens[1];
      if (tokens[2].indexOf('K') > -1) {
        this._castling.w |= BITS.KSIDE_CASTLE;
      }
      if (tokens[2].indexOf('Q') > -1) {
        this._castling.w |= BITS.QSIDE_CASTLE;
      }
      if (tokens[2].indexOf('k') > -1) {
        this._castling.b |= BITS.KSIDE_CASTLE;
      }
      if (tokens[2].indexOf('q') > -1) {
        this._castling.b |= BITS.QSIDE_CASTLE;
      }
      this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3]];
      this._halfMoves = parseInt(tokens[4], 10);
      this._moveNumber = parseInt(tokens[5], 10);
      this._hash = this._computeHash();
      this._updateSetup(fen);
      this._incPositionCount();
    }
    fen({ forceEnpassantSquare = false } = {}) {
      let empty = 0;
      let fen = '';
      for (let i = Ox88.a8; i <= Ox88.h1; i++) {
        if (this._board[i]) {
          if (empty > 0) {
            fen += empty;
            empty = 0;
          }
          const { color, type: piece } = this._board[i];
          fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase();
        } else {
          empty++;
        }
        if ((i + 1) & 0x88) {
          if (empty > 0) {
            fen += empty;
          }
          if (i !== Ox88.h1) {
            fen += '/';
          }
          empty = 0;
          i += 8;
        }
      }
      let castling = '';
      if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {
        castling += 'K';
      }
      if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {
        castling += 'Q';
      }
      if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {
        castling += 'k';
      }
      if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {
        castling += 'q';
      }
      // do we have an empty castling flag?
      castling = castling || '-';
      let epSquare = '-';
      /*
       * only print the ep square if en passant is a valid move (pawn is present
       * and ep capture is not pinned)
       */
      if (this._epSquare !== EMPTY) {
        if (forceEnpassantSquare) {
          epSquare = algebraic(this._epSquare);
        } else {
          const bigPawnSquare =
            this._epSquare + (this._turn === WHITE ? 16 : -16);
          const squares = [bigPawnSquare + 1, bigPawnSquare - 1];
          for (const square of squares) {
            // is the square off the board?
            if (square & 0x88) {
              continue;
            }
            const color = this._turn;
            // is there a pawn that can capture the epSquare?
            if (
              this._board[square]?.color === color &&
              this._board[square]?.type === PAWN
            ) {
              // if the pawn makes an ep capture, does it leave its king in check?
              this._makeMove({
                color,
                from: square,
                to: this._epSquare,
                piece: PAWN,
                captured: PAWN,
                flags: BITS.EP_CAPTURE,
              });
              const isLegal = !this._isKingAttacked(color);
              this._undoMove();
              // if ep is legal, break and set the ep square in the FEN output
              if (isLegal) {
                epSquare = algebraic(this._epSquare);
                break;
              }
            }
          }
        }
      }
      return [
        fen,
        this._turn,
        castling,
        epSquare,
        this._halfMoves,
        this._moveNumber,
      ].join(' ');
    }
    _pieceKey(i) {
      if (!this._board[i]) {
        return 0n;
      }
      const { color, type } = this._board[i];
      const colorIndex = {
        w: 0,
        b: 1,
      }[color];
      const typeIndex = {
        p: 0,
        n: 1,
        b: 2,
        r: 3,
        q: 4,
        k: 5,
      }[type];
      return PIECE_KEYS[colorIndex][typeIndex][i];
    }
    _epKey() {
      return this._epSquare === EMPTY ? 0n : EP_KEYS[this._epSquare & 7];
    }
    _castlingKey() {
      const index = (this._castling.w >> 5) | (this._castling.b >> 3);
      return CASTLING_KEYS[index];
    }
    _computeHash() {
      let hash = 0n;
      for (let i = Ox88.a8; i <= Ox88.h1; i++) {
        // did we run off the end of the board
        if (i & 0x88) {
          i += 7;
          continue;
        }
        if (this._board[i]) {
          hash ^= this._pieceKey(i);
        }
      }
      hash ^= this._epKey();
      hash ^= this._castlingKey();
      if (this._turn === 'b') {
        hash ^= SIDE_KEY;
      }
      return hash;
    }
    /*
     * Called when the initial board setup is changed with put() or remove().
     * modifies the SetUp and FEN properties of the header object. If the FEN
     * is equal to the default position, the SetUp and FEN are deleted the setup
     * is only updated if history.length is zero, ie moves haven't been made.
     */
    _updateSetup(fen) {
      if (this._history.length > 0) return;
      if (fen !== DEFAULT_POSITION) {
        this._header['SetUp'] = '1';
        this._header['FEN'] = fen;
      } else {
        this._header['SetUp'] = null;
        this._header['FEN'] = null;
      }
    }
    reset() {
      this.load(DEFAULT_POSITION);
    }
    get(square) {
      return this._board[Ox88[square]];
    }
    findPiece(piece) {
      const squares = [];
      for (let i = Ox88.a8; i <= Ox88.h1; i++) {
        // did we run off the end of the board
        if (i & 0x88) {
          i += 7;
          continue;
        }
        // if empty square or wrong color
        if (!this._board[i] || this._board[i]?.color !== piece.color) {
          continue;
        }
        // check if square contains the requested piece
        if (
          this._board[i].color === piece.color &&
          this._board[i].type === piece.type
        ) {
          squares.push(algebraic(i));
        }
      }
      return squares;
    }
    put({ type, color }, square) {
      if (this._put({ type, color }, square)) {
        this._updateCastlingRights();
        this._updateEnPassantSquare();
        this._updateSetup(this.fen());
        return true;
      }
      return false;
    }
    _set(sq, piece) {
      this._hash ^= this._pieceKey(sq);
      this._board[sq] = piece;
      this._hash ^= this._pieceKey(sq);
    }
    _put({ type, color }, square) {
      // check for piece
      if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {
        return false;
      }
      // check for valid square
      if (!(square in Ox88)) {
        return false;
      }
      const sq = Ox88[square];
      // don't let the user place more than one king
      if (
        type == KING &&
        !(this._kings[color] == EMPTY || this._kings[color] == sq)
      ) {
        return false;
      }
      const currentPieceOnSquare = this._board[sq];
      // if one of the kings will be replaced by the piece from args, set the `_kings` respective entry to `EMPTY`
      if (currentPieceOnSquare && currentPieceOnSquare.type === KING) {
        this._kings[currentPieceOnSquare.color] = EMPTY;
      }
      this._set(sq, { type: type, color: color });
      if (type === KING) {
        this._kings[color] = sq;
      }
      return true;
    }
    _clear(sq) {
      this._hash ^= this._pieceKey(sq);
      delete this._board[sq];
    }
    remove(square) {
      const piece = this.get(square);
      this._clear(Ox88[square]);
      if (piece && piece.type === KING) {
        this._kings[piece.color] = EMPTY;
      }
      this._updateCastlingRights();
      this._updateEnPassantSquare();
      this._updateSetup(this.fen());
      return piece;
    }
    _updateCastlingRights() {
      this._hash ^= this._castlingKey();
      const whiteKingInPlace =
        this._board[Ox88.e1]?.type === KING &&
        this._board[Ox88.e1]?.color === WHITE;
      const blackKingInPlace =
        this._board[Ox88.e8]?.type === KING &&
        this._board[Ox88.e8]?.color === BLACK;
      if (
        !whiteKingInPlace ||
        this._board[Ox88.a1]?.type !== ROOK ||
        this._board[Ox88.a1]?.color !== WHITE
      ) {
        this._castling.w &= -65;
      }
      if (
        !whiteKingInPlace ||
        this._board[Ox88.h1]?.type !== ROOK ||
        this._board[Ox88.h1]?.color !== WHITE
      ) {
        this._castling.w &= -33;
      }
      if (
        !blackKingInPlace ||
        this._board[Ox88.a8]?.type !== ROOK ||
        this._board[Ox88.a8]?.color !== BLACK
      ) {
        this._castling.b &= -65;
      }
      if (
        !blackKingInPlace ||
        this._board[Ox88.h8]?.type !== ROOK ||
        this._board[Ox88.h8]?.color !== BLACK
      ) {
        this._castling.b &= -33;
      }
      this._hash ^= this._castlingKey();
    }
    _updateEnPassantSquare() {
      if (this._epSquare === EMPTY) {
        return;
      }
      const startSquare = this._epSquare + (this._turn === WHITE ? -16 : 16);
      const currentSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);
      const attackers = [currentSquare + 1, currentSquare - 1];
      if (
        this._board[startSquare] !== null ||
        this._board[this._epSquare] !== null ||
        this._board[currentSquare]?.color !== swapColor(this._turn) ||
        this._board[currentSquare]?.type !== PAWN
      ) {
        this._hash ^= this._epKey();
        this._epSquare = EMPTY;
        return;
      }
      const canCapture = (square) =>
        !(square & 0x88) &&
        this._board[square]?.color === this._turn &&
        this._board[square]?.type === PAWN;
      if (!attackers.some(canCapture)) {
        this._hash ^= this._epKey();
        this._epSquare = EMPTY;
      }
    }
    _attacked(color, square, verbose) {
      const attackers = [];
      for (let i = Ox88.a8; i <= Ox88.h1; i++) {
        // did we run off the end of the board
        if (i & 0x88) {
          i += 7;
          continue;
        }
        // if empty square or wrong color
        if (this._board[i] === undefined || this._board[i].color !== color) {
          continue;
        }
        const piece = this._board[i];
        const difference = i - square;
        // skip - to/from square are the same
        if (difference === 0) {
          continue;
        }
        const index = difference + 119;
        if (ATTACKS[index] & PIECE_MASKS[piece.type]) {
          if (piece.type === PAWN) {
            if (
              (difference > 0 && piece.color === WHITE) ||
              (difference <= 0 && piece.color === BLACK)
            ) {
              if (!verbose) {
                return true;
              } else {
                attackers.push(algebraic(i));
              }
            }
            continue;
          }
          // if the piece is a knight or a king
          if (piece.type === 'n' || piece.type === 'k') {
            if (!verbose) {
              return true;
            } else {
              attackers.push(algebraic(i));
              continue;
            }
          }
          const offset = RAYS[index];
          let j = i + offset;
          let blocked = false;
          while (j !== square) {
            if (this._board[j] != null) {
              blocked = true;
              break;
            }
            j += offset;
          }
          if (!blocked) {
            if (!verbose) {
              return true;
            } else {
              attackers.push(algebraic(i));
              continue;
            }
          }
        }
      }
      if (verbose) {
        return attackers;
      } else {
        return false;
      }
    }
    attackers(square, attackedBy) {
      if (!attackedBy) {
        return this._attacked(this._turn, Ox88[square], true);
      } else {
        return this._attacked(attackedBy, Ox88[square], true);
      }
    }
    _isKingAttacked(color) {
      const square = this._kings[color];
      return square === -1 ? false : this._attacked(swapColor(color), square);
    }
    hash() {
      return this._hash.toString(16);
    }
    isAttacked(square, attackedBy) {
      return this._attacked(attackedBy, Ox88[square]);
    }
    isCheck() {
      return this._isKingAttacked(this._turn);
    }
    inCheck() {
      return this.isCheck();
    }
    isCheckmate() {
      return this.isCheck() && this._moves().length === 0;
    }
    isStalemate() {
      return !this.isCheck() && this._moves().length === 0;
    }
    isInsufficientMaterial() {
      /*
       * k.b. vs k.b. (of opposite colors) with mate in 1:
       * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1
       *
       * k.b. vs k.n. with mate in 1:
       * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1
       */
      const pieces = {
        b: 0,
        n: 0,
        r: 0,
        q: 0,
        k: 0,
        p: 0,
      };
      const bishops = [];
      let numPieces = 0;
      let squareColor = 0;
      for (let i = Ox88.a8; i <= Ox88.h1; i++) {
        squareColor = (squareColor + 1) % 2;
        if (i & 0x88) {
          i += 7;
          continue;
        }
        const piece = this._board[i];
        if (piece) {
          pieces[piece.type] =
            piece.type in pieces ? pieces[piece.type] + 1 : 1;
          if (piece.type === BISHOP) {
            bishops.push(squareColor);
          }
          numPieces++;
        }
      }
      // k vs. k
      if (numPieces === 2) {
        return true;
      } else if (
        // k vs. kn .... or .... k vs. kb
        numPieces === 3 &&
        (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)
      ) {
        return true;
      } else if (numPieces === pieces[BISHOP] + 2) {
        // kb vs. kb where any number of bishops are all on the same color
        let sum = 0;
        const len = bishops.length;
        for (let i = 0; i < len; i++) {
          sum += bishops[i];
        }
        if (sum === 0 || sum === len) {
          return true;
        }
      }
      return false;
    }
    isThreefoldRepetition() {
      return this._getPositionCount(this._hash) >= 3;
    }
    isDrawByFiftyMoves() {
      return this._halfMoves >= 100; // 50 moves per side = 100 half moves
    }
    isDraw() {
      return (
        this.isDrawByFiftyMoves() ||
        this.isStalemate() ||
        this.isInsufficientMaterial() ||
        this.isThreefoldRepetition()
      );
    }
    isGameOver() {
      return this.isCheckmate() || this.isDraw();
    }
    moves({ verbose = false, square = undefined, piece = undefined } = {}) {
      const moves = this._moves({ square, piece });
      if (verbose) {
        return moves.map((move) => new Move(this, move));
      } else {
        return moves.map((move) => this._moveToSan(move, moves));
      }
    }
    _moves({ legal = true, piece = undefined, square = undefined } = {}) {
      const forSquare = square ? square.toLowerCase() : undefined;
      const forPiece = piece?.toLowerCase();
      const moves = [];
      const us = this._turn;
      const them = swapColor(us);
      let firstSquare = Ox88.a8;
      let lastSquare = Ox88.h1;
      let singleSquare = false;
      // are we generating moves for a single square?
      if (forSquare) {
        // illegal square, return empty moves
        if (!(forSquare in Ox88)) {
          return [];
        } else {
          firstSquare = lastSquare = Ox88[forSquare];
          singleSquare = true;
        }
      }
      for (let from = firstSquare; from <= lastSquare; from++) {
        // did we run off the end of the board
        if (from & 0x88) {
          from += 7;
          continue;
        }
        // empty square or opponent, skip
        if (!this._board[from] || this._board[from].color === them) {
          continue;
        }
        const { type } = this._board[from];
        let to;
        if (type === PAWN) {
          if (forPiece && forPiece !== type) continue;
          // single square, non-capturing
          to = from + PAWN_OFFSETS[us][0];
          if (!this._board[to]) {
            addMove(moves, us, from, to, PAWN);
            // double square
            to = from + PAWN_OFFSETS[us][1];
            if (SECOND_RANK[us] === rank(from) && !this._board[to]) {
              addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN);
            }
          }
          // pawn captures
          for (let j = 2; j < 4; j++) {
            to = from + PAWN_OFFSETS[us][j];
            if (to & 0x88) continue;
            if (this._board[to]?.color === them) {
              addMove(
                moves,
                us,
                from,
                to,
                PAWN,
                this._board[to].type,
                BITS.CAPTURE,
              );
            } else if (to === this._epSquare) {
              addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE);
            }
          }
        } else {
          if (forPiece && forPiece !== type) continue;
          for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {
            const offset = PIECE_OFFSETS[type][j];
            to = from;
            while (true) {
              to += offset;
              if (to & 0x88) break;
              if (!this._board[to]) {
                addMove(moves, us, from, to, type);
              } else {
                // own color, stop loop
                if (this._board[to].color === us) break;
                addMove(
                  moves,
                  us,
                  from,
                  to,
                  type,
                  this._board[to].type,
                  BITS.CAPTURE,
                );
                break;
              }
              /* break, if knight or king */
              if (type === KNIGHT || type === KING) break;
            }
          }
        }
      }
      /*
       * check for castling if we're:
       *   a) generating all moves, or
       *   b) doing single square move generation on the king's square
       */
      if (forPiece === undefined || forPiece === KING) {
        if (!singleSquare || lastSquare === this._kings[us]) {
          // king-side castling
          if (this._castling[us] & BITS.KSIDE_CASTLE) {
            const castlingFrom = this._kings[us];
            const castlingTo = castlingFrom + 2;
            if (
              !this._board[castlingFrom + 1] &&
              !this._board[castlingTo] &&
              !this._attacked(them, this._kings[us]) &&
              !this._attacked(them, castlingFrom + 1) &&
              !this._attacked(them, castlingTo)
            ) {
              addMove(
                moves,
                us,
                this._kings[us],
                castlingTo,
                KING,
                undefined,
                BITS.KSIDE_CASTLE,
              );
            }
          }
          // queen-side castling
          if (this._castling[us] & BITS.QSIDE_CASTLE) {
            const castlingFrom = this._kings[us];
            const castlingTo = castlingFrom - 2;
            if (
              !this._board[castlingFrom - 1] &&
              !this._board[castlingFrom - 2] &&
              !this._board[castlingFrom - 3] &&
              !this._attacked(them, this._kings[us]) &&
              !this._attacked(them, castlingFrom - 1) &&
              !this._attacked(them, castlingTo)
            ) {
              addMove(
                moves,
                us,
                this._kings[us],
                castlingTo,
                KING,
                undefined,
                BITS.QSIDE_CASTLE,
              );
            }
          }
        }
      }
      /*
       * return all pseudo-legal moves (this includes moves that allow the king
       * to be captured)
       */
      if (!legal || this._kings[us] === -1) {
        return moves;
      }
      // filter out illegal moves
      const legalMoves = [];
      for (let i = 0, len = moves.length; i < len; i++) {
        this._makeMove(moves[i]);
        if (!this._isKingAttacked(us)) {
          legalMoves.push(moves[i]);
        }
        this._undoMove();
      }
      return legalMoves;
    }
    move(move, { strict = false } = {}) {
      /*
       * The move function can be called with in the following parameters:
       *
       * .move('Nxb7')       <- argument is a case-sensitive SAN string
       *
       * .move({ from: 'h7', <- argument is a move object
       *         to :'h8',
       *         promotion: 'q' })
       *
       *
       * An optional strict argument may be supplied to tell chess.js to
       * strictly follow the SAN specification.
       */
      let moveObj = null;
      if (typeof move === 'string') {
        moveObj = this._moveFromSan(move, strict);
      } else if (move === null) {
        moveObj = this._moveFromSan(SAN_NULLMOVE, strict);
      } else if (typeof move === 'object') {
        const moves = this._moves();
        // convert the pretty move object to an ugly move object
        for (let i = 0, len = moves.length; i < len; i++) {
          if (
            move.from === algebraic(moves[i].from) &&
            move.to === algebraic(moves[i].to) &&
            (!('promotion' in moves[i]) ||
              move.promotion === moves[i].promotion)
          ) {
            moveObj = moves[i];
            break;
          }
        }
      }
      // failed to find move
      if (!moveObj) {
        if (typeof move === 'string') {
          throw new Error(`Invalid move: ${move}`);
        } else {
          throw new Error(`Invalid move: ${JSON.stringify(move)}`);
        }
      }
      //disallow null moves when in check
      if (this.isCheck() && moveObj.flags & BITS.NULL_MOVE) {
        throw new Error('Null move not allowed when in check');
      }
      /*
       * need to make a copy of move because we can't generate SAN after the move
       * is made
       */
      const prettyMove = new Move(this, moveObj);
      this._makeMove(moveObj);
      this._incPositionCount();
      return prettyMove;
    }
    _push(move) {
      this._history.push({
        move,
        kings: { b: this._kings.b, w: this._kings.w },
        turn: this._turn,
        castling: { b: this._castling.b, w: this._castling.w },
        epSquare: this._epSquare,
        halfMoves: this._halfMoves,
        moveNumber: this._moveNumber,
      });
    }
    _movePiece(from, to) {
      this._hash ^= this._pieceKey(from);
      this._board[to] = this._board[from];
      delete this._board[from];
      this._hash ^= this._pieceKey(to);
    }
    _makeMove(move) {
      const us = this._turn;
      const them = swapColor(us);
      this._push(move);
      if (move.flags & BITS.NULL_MOVE) {
        if (us === BLACK) {
          this._moveNumber++;
        }
        this._halfMoves++;
        this._turn = them;
        this._epSquare = EMPTY;
        return;
      }
      this._hash ^= this._epKey();
      this._hash ^= this._castlingKey();
      if (move.captured) {
        this._hash ^= this._pieceKey(move.to);
      }
      this._movePiece(move.from, move.to);
      // if ep capture, remove the captured pawn
      if (move.flags & BITS.EP_CAPTURE) {
        if (this._turn === BLACK) {
          this._clear(move.to - 16);
        } else {
          this._clear(move.to + 16);
        }
      }
      // if pawn promotion, replace with new piece
      if (move.promotion) {
        this._clear(move.to);
        this._set(move.to, { type: move.promotion, color: us });
      }
      // if we moved the king
      if (this._board[move.to].type === KING) {
        this._kings[us] = move.to;
        // if we castled, move the rook next to the king
        if (move.flags & BITS.KSIDE_CASTLE) {
          const castlingTo = move.to - 1;
          const castlingFrom = move.to + 1;
          this._movePiece(castlingFrom, castlingTo);
        } else if (move.flags & BITS.QSIDE_CASTLE) {
          const castlingTo = move.to + 1;
          const castlingFrom = move.to - 2;
          this._movePiece(castlingFrom, castlingTo);
        }
        // turn off castling
        this._castling[us] = 0;
      }
      // turn off castling if we move a rook
      if (this._castling[us]) {
        for (let i = 0, len = ROOKS[us].length; i < len; i++) {
          if (
            move.from === ROOKS[us][i].square &&
            this._castling[us] & ROOKS[us][i].flag
          ) {
            this._castling[us] ^= ROOKS[us][i].flag;
            break;
          }
        }
      }
      // turn off castling if we capture a rook
      if (this._castling[them]) {
        for (let i = 0, len = ROOKS[them].length; i < len; i++) {
          if (
            move.to === ROOKS[them][i].square &&
            this._castling[them] & ROOKS[them][i].flag
          ) {
            this._castling[them] ^= ROOKS[them][i].flag;
            break;
          }
        }
      }
      this._hash ^= this._castlingKey();
      // if big pawn move, update the en passant square
      if (move.flags & BITS.BIG_PAWN) {
        let epSquare;
        if (us === BLACK) {
          epSquare = move.to - 16;
        } else {
          epSquare = move.to + 16;
        }
        if (
          (!((move.to - 1) & 0x88) &&
            this._board[move.to - 1]?.type === PAWN &&
            this._board[move.to - 1]?.color === them) ||
          (!((move.to + 1) & 0x88) &&
            this._board[move.to + 1]?.type === PAWN &&
            this._board[move.to + 1]?.color === them)
        ) {
          this._epSquare = epSquare;
          this._hash ^= this._epKey();
        } else {
          this._epSquare = EMPTY;
        }
      } else {
        this._epSquare = EMPTY;
      }
      // reset the 50 move counter if a pawn is moved or a piece is captured
      if (move.piece === PAWN) {
        this._halfMoves = 0;
      } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {
        this._halfMoves = 0;
      } else {
        this._halfMoves++;
      }
      if (us === BLACK) {
        this._moveNumber++;
      }
      this._turn = them;
      this._hash ^= SIDE_KEY;
    }
    undo() {
      const hash = this._hash;
      const move = this._undoMove();
      if (move) {
        const prettyMove = new Move(this, move);
        this._decPositionCount(hash);
        return prettyMove;
      }
      return null;
    }
    _undoMove() {
      const old = this._history.pop();
      if (old === undefined) {
        return null;
      }
      this._hash ^= this._epKey();
      this._hash ^= this._castlingKey();
      const move = old.move;
      this._kings = old.kings;
      this._turn = old.turn;
      this._castling = old.castling;
      this._epSquare = old.epSquare;
      this._halfMoves = old.halfMoves;
      this._moveNumber = old.moveNumber;
      this._hash ^= this._epKey();
      this._hash ^= this._castlingKey();
      this._hash ^= SIDE_KEY;
      const us = this._turn;
      const them = swapColor(us);
      if (move.flags & BITS.NULL_MOVE) {
        return move;
      }
      this._movePiece(move.to, move.from);
      // to undo any promotions
      if (move.piece) {
        this._clear(move.from);
        this._set(move.from, { type: move.piece, color: us });
      }
      if (move.captured) {
        if (move.flags & BITS.EP_CAPTURE) {
          // en passant capture
          let index;
          if (us === BLACK) {
            index = move.to - 16;
          } else {
            index = move.to + 16;
          }
          this._set(index, { type: PAWN, color: them });
        } else {
          // regular capture
          this._set(move.to, { type: move.captured, color: them });
        }
      }
      if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {
        let castlingTo, castlingFrom;
        if (move.flags & BITS.KSIDE_CASTLE) {
          castlingTo = move.to + 1;
          castlingFrom = move.to - 1;
        } else {
          castlingTo = move.to - 2;
          castlingFrom = move.to + 1;
        }
        this._movePiece(castlingFrom, castlingTo);
      }
      return move;
    }
    pgn({ newline = '\n', maxWidth = 0 } = {}) {
      /*
       * using the specification from http://www.chessclub.com/help/PGN-spec
       * example for html usage: .pgn({ max_width: 72, newline_char: "<br />" })
       */
      const result = [];
      let headerExists = false;
      /* add the PGN header information */
      for (const i in this._header) {
        /*
         * TODO: order of enumerated properties in header object is not
         * guaranteed, see ECMA-262 spec (section 12.6.4)
         *
         * By using HEADER_TEMPLATE, the order of tags should be preserved; we
         * do have to check for null placeholders, though, and omit them
         */
        const headerTag = this._header[i];
        if (headerTag) result.push(`[${i} "${this._header[i]}"]` + newline);
        headerExists = true;
      }
      if (headerExists && this._history.length) {
        result.push(newline);
      }
      const appendComment = (moveString) => {
        const comment = this._comments[this.fen()];
        if (typeof comment !== 'undefined') {
          const delimiter = moveString.length > 0 ? ' ' : '';
          moveString = `${moveString}${delimiter}{${comment}}`;
        }
        return moveString;
      };
      // pop all of history onto reversed_history
      const reversedHistory = [];
      while (this._history.length > 0) {
        reversedHistory.push(this._undoMove());
      }
      const moves = [];
      let moveString = '';
      // special case of a commented starting position with no moves
      if (reversedHistory.length === 0) {
        moves.push(appendComment(''));
      }
      // build the list of moves.  a move_string looks like: "3. e3 e6"
      while (reversedHistory.length > 0) {
        moveString = appendComment(moveString);
        const move = reversedHistory.pop();
        // make TypeScript stop complaining about move being undefined
        if (!move) {
          break;
        }
        // if the position started with black to move, start PGN with #. ...
        if (!this._history.length && move.color === 'b') {
          const prefix = `${this._moveNumber}. ...`;
          // is there a comment preceding the first move?
          moveString = moveString ? `${moveString} ${prefix}` : prefix;
        } else if (move.color === 'w') {
          // store the previous generated move_string if we have one
          if (moveString.length) {
            moves.push(moveString);
          }
          moveString = this._moveNumber + '.';
        }
        moveString =
          moveString +
          ' ' +
          this._moveToSan(move, this._moves({ legal: true }));
        this._makeMove(move);
      }
      // are there any other leftover moves?
      if (moveString.length) {
        moves.push(appendComment(moveString));
      }
      // is there a result? (there ALWAYS has to be a result according to spec; see Seven Tag Roster)
      moves.push(this._header.Result || '*');
      /*
       * history should be back to what it was before we started generating PGN,
       * so join together moves
       */
      if (maxWidth === 0) {
        return result.join('') + moves.join(' ');
      }
      // TODO (jah): huh?
      const strip = function () {
        if (result.length > 0 && result[result.length - 1] === ' ') {
          result.pop();
          return true;
        }
        return false;
      };
      // NB: this does not preserve comment whitespace.
      const wrapComment = function (width, move) {
        for (const token of move.split(' ')) {
          if (!token) {
            continue;
          }
          if (width + token.length > maxWidth) {
            while (strip()) {
              width--;
            }
            result.push(newline);
            width = 0;
          }
          result.push(token);
          width += token.length;
          result.push(' ');
          width++;
        }
        if (strip()) {
          width--;
        }
        return width;
      };
      // wrap the PGN output at max_width
      let currentWidth = 0;
      for (let i = 0; i < moves.length; i++) {
        if (currentWidth + moves[i].length > maxWidth) {
          if (moves[i].includes('{')) {
            currentWidth = wrapComment(currentWidth, moves[i]);
            continue;
          }
        }
        // if the current move will push past max_width
        if (currentWidth + moves[i].length > maxWidth && i !== 0) {
          // don't end the line with whitespace
          if (result[result.length - 1] === ' ') {
            result.pop();
          }
          result.push(newline);
          currentWidth = 0;
        } else if (i !== 0) {
          result.push(' ');
          currentWidth++;
        }
        result.push(moves[i]);
        currentWidth += moves[i].length;
      }
      return result.join('');
    }
    /**
     * @deprecated Use `setHeader` and `getHeaders` instead. This method will return null header tags (which is not what you want)
     */
    header(...args) {
      for (let i = 0; i < args.length; i += 2) {
        if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {
          this._header[args[i]] = args[i + 1];
        }
      }
      return this._header;
    }
    // TODO: value validation per spec
    setHeader(key, value) {
      this._header[key] = value ?? SEVEN_TAG_ROSTER[key] ?? null;
      return this.getHeaders();
    }
    removeHeader(key) {
      if (key in this._header) {
        this._header[key] = SEVEN_TAG_ROSTER[key] || null;
        return true;
      }
      return false;
    }
    // return only non-null headers (omit placemarker nulls)
    getHeaders() {
      const nonNullHeaders = {};
      for (const [key, value] of Object.entries(this._header)) {
        if (value !== null) {
          nonNullHeaders[key] = value;
        }
      }
      return nonNullHeaders;
    }
    loadPgn(pgn, { strict = false, newlineChar = '\r?\n' } = {}) {
      // If newlineChar is not the default, replace all instances with \n
      if (newlineChar !== '\r?\n') {
        pgn = pgn.replace(new RegExp(newlineChar, 'g'), '\n');
      }
      const parsedPgn = peg$parse(pgn);
      // Put the board in the starting position
      this.reset();
      // parse PGN header
      const headers = parsedPgn.headers;
      let fen = '';
      for (const key in headers) {
        // check to see user is including fen (possibly with wrong tag case)
        if (key.toLowerCase() === 'fen') {
          fen = headers[key];
        }
        this.header(key, headers[key]);
      }
      /*
       * the permissive parser should attempt to load a fen tag, even if it's the
       * wrong case and doesn't include a corresponding [SetUp "1"] tag
       */
      if (!strict) {
        if (fen) {
          this.load(fen, { preserveHeaders: true });
        }
      } else {
        /*
         * strict parser - load the starting position indicated by [Setup '1']
         * and [FEN position]
         */
        if (headers['SetUp'] === '1') {
          if (!('FEN' in headers)) {
            throw new Error(
              'Invalid PGN: FEN tag must be supplied with SetUp tag',
            );
          }
          // don't clear the headers when loading
          this.load(headers['FEN'], { preserveHeaders: true });
        }
      }
      let node = parsedPgn.root;
      while (node) {
        if (node.move) {
          const move = this._moveFromSan(node.move, strict);
          if (move == null) {
            throw new Error(`Invalid move in PGN: ${node.move}`);
          } else {
            this._makeMove(move);
            this._incPositionCount();
          }
        }
        if (node.comment !== undefined) {
          this._comments[this.fen()] = node.comment;
        }
        node = node.variations[0];
      }
      /*
       * Per section 8.2.6 of the PGN spec, the Result tag pair must match match
       * the termination marker. Only do this when headers are present, but the
       * result tag is missing
       */
      const result = parsedPgn.result;
      if (
        result &&
        Object.keys(this._header).length &&
        this._header['Result'] !== result
      ) {
        this.setHeader('Result', result);
      }
    }
    /*
     * Convert a move from 0x88 coordinates to Standard Algebraic Notation
     * (SAN)
     *
     * @param {boolean} strict Use the strict SAN parser. It will throw errors
     * on overly disambiguated moves (see below):
     *
     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4
     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned
     * 4. ... Ne7 is technically the valid SAN
     */
    _moveToSan(move, moves) {
      let output = '';
      if (move.flags & BITS.KSIDE_CASTLE) {
        output = 'O-O';
      } else if (move.flags & BITS.QSIDE_CASTLE) {
        output = 'O-O-O';
      } else if (move.flags & BITS.NULL_MOVE) {
        return SAN_NULLMOVE;
      } else {
        if (move.piece !== PAWN) {
          const disambiguator = getDisambiguator(move, moves);
          output += move.piece.toUpperCase() + disambiguator;
        }
        if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {
          if (move.piece === PAWN) {
            output += algebraic(move.from)[0];
          }
          output += 'x';
        }
        output += algebraic(move.to);
        if (move.promotion) {
          output += '=' + move.promotion.toUpperCase();
        }
      }
      this._makeMove(move);
      if (this.isCheck()) {
        if (this.isCheckmate()) {
          output += '#';
        } else {
          output += '+';
        }
      }
      this._undoMove();
      return output;
    }
    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates
    _moveFromSan(move, strict = false) {
      // strip off any move decorations: e.g Nf3+?! becomes Nf3
      let cleanMove = strippedSan(move);
      if (!strict) {
        if (cleanMove === '0-0') {
          cleanMove = 'O-O';
        } else if (cleanMove === '0-0-0') {
          cleanMove = 'O-O-O';
        }
      }
      //first implementation of null with a dummy move (black king moves from a8 to a8), maybe this can be implemented better
      if (cleanMove == SAN_NULLMOVE) {
        const res = {
          color: this._turn,
          from: 0,
          to: 0,
          piece: 'k',
          flags: BITS.NULL_MOVE,
        };
        return res;
      }
      let pieceType = inferPieceType(cleanMove);
      let moves = this._moves({ legal: true, piece: pieceType });
      // strict parser
      for (let i = 0, len = moves.length; i < len; i++) {
        if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {
          return moves[i];
        }
      }
      // the strict parser failed
      if (strict) {
        return null;
      }
      let piece = undefined;
      let matches = undefined;
      let from = undefined;
      let to = undefined;
      let promotion = undefined;
      /*
       * The default permissive (non-strict) parser allows the user to parse
       * non-standard chess notations. This parser is only run after the strict
       * Standard Algebraic Notation (SAN) parser has failed.
       *
       * When running the permissive parser, we'll run a regex to grab the piece, the
       * to/from square, and an optional promotion piece. This regex will
       * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,
       * f7f8q, b1c3
       *
       * NOTE: Some positions and moves may be ambiguous when using the permissive
       * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,
       * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop
       * move). In these cases, the permissive parser will default to the most
       * basic interpretation (which is b1c3 parsing to Nc3).
       */
      let overlyDisambiguated = false;
      matches = cleanMove.match(
        /([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/,
      );
      if (matches) {
        piece = matches[1];
        from = matches[2];
        to = matches[3];
        promotion = matches[4];
        if (from.length == 1) {
          overlyDisambiguated = true;
        }
      } else {
        /*
         * The [a-h]?[1-8]? portion of the regex below handles moves that may be
         * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when
         * there is one legal knight move to e7). In this case, the value of
         * 'from' variable will be a rank or file, not a square.
         */
        matches = cleanMove.match(
          /([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/,
        );
        if (matches) {
          piece = matches[1];
          from = matches[2];
          to = matches[3];
          promotion = matches[4];
          if (from.length == 1) {
            overlyDisambiguated = true;
          }
        }
      }
      pieceType = inferPieceType(cleanMove);
      moves = this._moves({
        legal: true,
        piece: piece ? piece : pieceType,
      });
      if (!to) {
        return null;
      }
      for (let i = 0, len = moves.length; i < len; i++) {
        if (!from) {
          // if there is no from square, it could be just 'x' missing from a capture
          if (
            cleanMove ===
            strippedSan(this._moveToSan(moves[i], moves)).replace('x', '')
          ) {
            return moves[i];
          }
          // hand-compare move properties with the results from our permissive regex
        } else if (
          (!piece || piece.toLowerCase() == moves[i].piece) &&
          Ox88[from] == moves[i].from &&
          Ox88[to] == moves[i].to &&
          (!promotion || promotion.toLowerCase() == moves[i].promotion)
        ) {
          return moves[i];
        } else if (overlyDisambiguated) {
          /*
           * SPECIAL CASE: we parsed a move string that may have an unneeded
           * rank/file disambiguator (e.g. Nge7).  The 'from' variable will
           */
          const square = algebraic(moves[i].from);
          if (
            (!piece || piece.toLowerCase() == moves[i].piece) &&
            Ox88[to] == moves[i].to &&
            (from == square[0] || from == square[1]) &&
            (!promotion || promotion.toLowerCase() == moves[i].promotion)
          ) {
            return moves[i];
          }
        }
      }
      return null;
    }
    ascii() {
      let s = '   +------------------------+\n';
      for (let i = Ox88.a8; i <= Ox88.h1; i++) {
        // display the rank
        if (file(i) === 0) {
          s += ' ' + '87654321'[rank(i)] + ' |';
        }
        if (this._board[i]) {
          const piece = this._board[i].type;
          const color = this._board[i].color;
          const symbol =
            color === WHITE ? piece.toUpperCase() : piece.toLowerCase();
          s += ' ' + symbol + ' ';
        } else {
          s += ' . ';
        }
        if ((i + 1) & 0x88) {
          s += '|\n';
          i += 8;
        }
      }
      s += '   +------------------------+\n';
      s += '     a  b  c  d  e  f  g  h';
      return s;
    }
    perft(depth) {
      const moves = this._moves({ legal: false });
      let nodes = 0;
      const color = this._turn;
      for (let i = 0, len = moves.length; i < len; i++) {
        this._makeMove(moves[i]);
        if (!this._isKingAttacked(color)) {
          if (depth - 1 > 0) {
            nodes += this.perft(depth - 1);
          } else {
            nodes++;
          }
        }
        this._undoMove();
      }
      return nodes;
    }
    setTurn(color) {
      if (this._turn == color) {
        return false;
      }
      this.move('--');
      return true;
    }
    turn() {
      return this._turn;
    }
    board() {
      const output = [];
      let row = [];
      for (let i = Ox88.a8; i <= Ox88.h1; i++) {
        if (this._board[i] == null) {
          row.push(null);
        } else {
          row.push({
            square: algebraic(i),
            type: this._board[i].type,
            color: this._board[i].color,
          });
        }
        if ((i + 1) & 0x88) {
          output.push(row);
          row = [];
          i += 8;
        }
      }
      return output;
    }
    squareColor(square) {
      if (square in Ox88) {
        const sq = Ox88[square];
        return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark';
      }
      return null;
    }
    history({ verbose = false } = {}) {
      const reversedHistory = [];
      const moveHistory = [];
      while (this._history.length > 0) {
        reversedHistory.push(this._undoMove());
      }
      while (true) {
        const move = reversedHistory.pop();
        if (!move) {
          break;
        }
        if (verbose) {
          moveHistory.push(new Move(this, move));
        } else {
          moveHistory.push(this._moveToSan(move, this._moves()));
        }
        this._makeMove(move);
      }
      return moveHistory;
    }
    /*
     * Keeps track of position occurrence counts for the purpose of repetition
     * checking. Old positions are removed from the map if their counts are reduced to 0.
     */
    _getPositionCount(hash) {
      return this._positionCount.get(hash) ?? 0;
    }
    _incPositionCount() {
      this._positionCount.set(
        this._hash,
        (this._positionCount.get(this._hash) ?? 0) + 1,
      );
    }
    _decPositionCount(hash) {
      const currentCount = this._positionCount.get(hash) ?? 0;
      if (currentCount === 1) {
        this._positionCount.delete(hash);
      } else {
        this._positionCount.set(hash, currentCount - 1);
      }
    }
    _pruneComments() {
      const reversedHistory = [];
      const currentComments = {};
      const copyComment = (fen) => {
        if (fen in this._comments) {
          currentComments[fen] = this._comments[fen];
        }
      };
      while (this._history.length > 0) {
        reversedHistory.push(this._undoMove());
      }
      copyComment(this.fen());
      while (true) {
        const move = reversedHistory.pop();
        if (!move) {
          break;
        }
        this._makeMove(move);
        copyComment(this.fen());
      }
      this._comments = currentComments;
    }
    getComment() {
      return this._comments[this.fen()];
    }
    setComment(comment) {
      this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');
    }
    /**
     * @deprecated Renamed to `removeComment` for consistency
     */
    deleteComment() {
      return this.removeComment();
    }
    removeComment() {
      const comment = this._comments[this.fen()];
      delete this._comments[this.fen()];
      return comment;
    }
    getComments() {
      this._pruneComments();
      return Object.keys(this._comments).map((fen) => {
        return { fen: fen, comment: this._comments[fen] };
      });
    }
    /**
     * @deprecated Renamed to `removeComments` for consistency
     */
    deleteComments() {
      return this.removeComments();
    }
    removeComments() {
      this._pruneComments();
      return Object.keys(this._comments).map((fen) => {
        const comment = this._comments[fen];
        delete this._comments[fen];
        return { fen: fen, comment: comment };
      });
    }
    setCastlingRights(color, rights) {
      for (const side of [KING, QUEEN]) {
        if (rights[side] !== undefined) {
          if (rights[side]) {
            this._castling[color] |= SIDES[side];
          } else {
            this._castling[color] &= ~SIDES[side];
          }
        }
      }
      this._updateCastlingRights();
      const result = this.getCastlingRights(color);
      return (
        (rights[KING] === undefined || rights[KING] === result[KING]) &&
        (rights[QUEEN] === undefined || rights[QUEEN] === result[QUEEN])
      );
    }
    getCastlingRights(color) {
      return {
        [KING]: (this._castling[color] & SIDES[KING]) !== 0,
        [QUEEN]: (this._castling[color] & SIDES[QUEEN]) !== 0,
      };
    }
    moveNumber() {
      return this._moveNumber;
    }
  }

  /**
   * @module engine
   * Game-state wrapper around chess.js that:
   * - Tracks step in the SAN sequence
   * - Compares played vs expected using {from,to}
   * - Restores on incorrect move
   */
  if (typeof window !== 'undefined' && !('Chess' in window)) {
    window.Chess = Chess;
  }
  function resolveChessCtor() {
    const ctor =
      window.Chess || (window.chess && (window.chess.Chess || window.chess));
    if (!ctor)
      throw new Error(
        'chess.js global not found; need UMD build exposing window.Chess',
      );
    return ctor;
  }
  function createEngine(params) {
    const ChessCtor = resolveChessCtor();
    const startFen =
      params.fen && params.fen.trim() !== '' ? params.fen : 'start';
    const game = new ChessCtor(startFen === 'start' ? undefined : startFen);
    let step = 0;
    const seq = params.sanSeq.slice();
    function expectedMove() {
      try {
        const tmp = new ChessCtor(game.fen());
        const exp = tmp.move(seq[step], { sloppy: true });
        if (!exp) return undefined;
        return { from: exp.from, to: exp.to };
      } catch {
        return undefined;
      }
    }
    function tryUserMove(move) {
      const fenBefore = game.fen();
      const mv = game.move({ from: move.from, to: move.to, promotion: 'q' });
      if (!mv) {
        // illegal move in chess.js terms  snapback and restore
        return { correct: false, snapback: true, fen: fenBefore };
      }
      const exp = expectedMove();
      const correct = !!exp && mv.from === exp.from && mv.to === exp.to;
      if (!correct) {
        game.undo();
        return {
          correct: false,
          snapback: true,
          fen: fenBefore,
          expected: exp,
        };
      }
      step += 1;
      return { correct: true, snapback: false, fen: game.fen() };
    }
    return {
      tryUserMove,
      expectedMove,
      getFen: () => game.fen(),
      getStep: () => step,
      getTotal: () => seq.length,
      getSeq: () => seq,
    };
  }

  function getDefaultExportFromCjs(x) {
    return x &&
      x.__esModule &&
      Object.prototype.hasOwnProperty.call(x, 'default')
      ? x['default']
      : x;
  }

  /*!
   * chessboard.js $version$
   *
   * Copyright 2013 Chris Oakman
   * Released under the MIT license
   * https://github.com/oakmac/chessboardjs/blob/master/LICENSE
   *
   * Date: $date$
   */

  var chessboard;
  var hasRequiredChessboard;

  function requireChessboard() {
    if (hasRequiredChessboard) return chessboard;
    hasRequiredChessboard = 1;
    //------------------------------------------------------------------------------
    // Chess Util Functions
    //------------------------------------------------------------------------------
    var COLUMNS = 'abcdefgh'.split('');

    function validMove(move) {
      // move should be a string
      if (typeof move !== 'string') return false;

      // move should be in the form of "e2-e4", "f6-d5"
      var tmp = move.split('-');
      if (tmp.length !== 2) return false;

      return validSquare(tmp[0]) === true && validSquare(tmp[1]) === true;
    }

    function validSquare(square) {
      if (typeof square !== 'string') return false;
      return square.search(/^[a-h][1-8]$/) !== -1;
    }

    function validPieceCode(code) {
      if (typeof code !== 'string') return false;
      return code.search(/^[bw][KQRNBP]$/) !== -1;
    }

    // TODO: this whole function could probably be replaced with a single regex
    function validFen(fen) {
      if (typeof fen !== 'string') return false;

      // cut off any move, castling, etc info from the end
      // we're only interested in position information
      fen = fen.replace(/ .+$/, '');

      // FEN should be 8 sections separated by slashes
      var chunks = fen.split('/');
      if (chunks.length !== 8) return false;

      // check the piece sections
      for (var i = 0; i < 8; i++) {
        if (
          chunks[i] === '' ||
          chunks[i].length > 8 ||
          chunks[i].search(/[^kqrbnpKQRNBP1-8]/) !== -1
        ) {
          return false;
        }
      }

      return true;
    }

    function validPositionObject(pos) {
      if (typeof pos !== 'object') return false;

      for (var i in pos) {
        if (pos.hasOwnProperty(i) !== true) continue;

        if (validSquare(i) !== true || validPieceCode(pos[i]) !== true) {
          return false;
        }
      }

      return true;
    }

    // convert FEN piece code to bP, wK, etc
    function fenToPieceCode(piece) {
      // black piece
      if (piece.toLowerCase() === piece) {
        return 'b' + piece.toUpperCase();
      }

      // white piece
      return 'w' + piece.toUpperCase();
    }

    // convert bP, wK, etc code to FEN structure
    function pieceCodeToFen(piece) {
      var tmp = piece.split('');

      // white piece
      if (tmp[0] === 'w') {
        return tmp[1].toUpperCase();
      }

      // black piece
      return tmp[1].toLowerCase();
    }

    // convert FEN string to position object
    // returns false if the FEN string is invalid
    function fenToObj(fen) {
      if (validFen(fen) !== true) {
        return false;
      }

      // cut off any move, castling, etc info from the end
      // we're only interested in position information
      fen = fen.replace(/ .+$/, '');

      var rows = fen.split('/');
      var position = {};

      var currentRow = 8;
      for (var i = 0; i < 8; i++) {
        var row = rows[i].split('');
        var colIndex = 0;

        // loop through each character in the FEN section
        for (var j = 0; j < row.length; j++) {
          // number / empty squares
          if (row[j].search(/[1-8]/) !== -1) {
            var emptySquares = parseInt(row[j], 10);
            colIndex += emptySquares;
          }
          // piece
          else {
            var square = COLUMNS[colIndex] + currentRow;
            position[square] = fenToPieceCode(row[j]);
            colIndex++;
          }
        }

        currentRow--;
      }

      return position;
    }

    // position object to FEN string
    // returns false if the obj is not a valid position object
    function objToFen(obj) {
      if (validPositionObject(obj) !== true) {
        return false;
      }

      var fen = '';

      var currentRow = 8;
      for (var i = 0; i < 8; i++) {
        for (var j = 0; j < 8; j++) {
          var square = COLUMNS[j] + currentRow;

          // piece exists
          if (obj.hasOwnProperty(square) === true) {
            fen += pieceCodeToFen(obj[square]);
          }

          // empty space
          else {
            fen += '1';
          }
        }

        if (i !== 7) {
          fen += '/';
        }

        currentRow--;
      }

      // squeeze the numbers together
      // haha, I love this solution...
      fen = fen.replace(/11111111/g, '8');
      fen = fen.replace(/1111111/g, '7');
      fen = fen.replace(/111111/g, '6');
      fen = fen.replace(/11111/g, '5');
      fen = fen.replace(/1111/g, '4');
      fen = fen.replace(/111/g, '3');
      fen = fen.replace(/11/g, '2');

      return fen;
    }

    var ChessBoard = function (containerElOrId, cfg) {
      cfg = cfg || {};

      //------------------------------------------------------------------------------
      // Constants
      //------------------------------------------------------------------------------

      var MINIMUM_JQUERY_VERSION = '1.7.0',
        START_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR',
        START_POSITION = fenToObj(START_FEN);

      // use unique class names to prevent clashing with anything else on the page
      // and simplify selectors
      // NOTE: these should never change
      var CSS = {
        alpha: 'alpha-d2270',
        black: 'black-3c85d',
        board: 'board-b72b1',
        chessboard: 'chessboard-63f37',
        clearfix: 'clearfix-7da63',
        highlight1: 'highlight1-32417',
        highlight2: 'highlight2-9c5d2',
        notation: 'notation-322f9',
        numeric: 'numeric-fc462',
        piece: 'piece-417db',
        row: 'row-5277c',
        sparePieces: 'spare-pieces-7492f',
        sparePiecesBottom: 'spare-pieces-bottom-ae20f',
        sparePiecesTop: 'spare-pieces-top-4028b',
        square: 'square-55d63',
        white: 'white-1e1d7',
      };

      //------------------------------------------------------------------------------
      // Module Scope Variables
      //------------------------------------------------------------------------------

      // DOM elements
      var containerEl,
        boardEl,
        draggedPieceEl,
        sparePiecesTopEl,
        sparePiecesBottomEl;

      // constructor return object
      var widget = {};

      //------------------------------------------------------------------------------
      // Stateful
      //------------------------------------------------------------------------------

      var BOARD_BORDER_SIZE = 2,
        CURRENT_ORIENTATION = 'white',
        CURRENT_POSITION = {},
        SQUARE_SIZE,
        DRAGGED_PIECE,
        DRAGGED_PIECE_LOCATION,
        DRAGGED_PIECE_SOURCE,
        DRAGGING_A_PIECE = false,
        SPARE_PIECE_ELS_IDS = {},
        SQUARE_ELS_IDS = {},
        SQUARE_ELS_OFFSETS;

      //------------------------------------------------------------------------------
      // JS Util Functions
      //------------------------------------------------------------------------------

      // http://tinyurl.com/3ttloxj
      function uuid() {
        return 'xxxx-xxxx-xxxx-xxxx-xxxx-xxxx-xxxx-xxxx'.replace(
          /x/g,
          function (c) {
            var r = (Math.random() * 16) | 0;
            return r.toString(16);
          },
        );
      }

      function deepCopy(thing) {
        return JSON.parse(JSON.stringify(thing));
      }

      function parseSemVer(version) {
        var tmp = version.split('.');
        return {
          major: parseInt(tmp[0], 10),
          minor: parseInt(tmp[1], 10),
          patch: parseInt(tmp[2], 10),
        };
      }

      // returns true if version is >= minimum
      function compareSemVer(version, minimum) {
        version = parseSemVer(version);
        minimum = parseSemVer(minimum);

        var versionNum =
          version.major * 10000 * 10000 + version.minor * 10000 + version.patch;
        var minimumNum =
          minimum.major * 10000 * 10000 + minimum.minor * 10000 + minimum.patch;

        return versionNum >= minimumNum;
      }

      //------------------------------------------------------------------------------
      // Validation / Errors
      //------------------------------------------------------------------------------

      function error(code, msg, obj) {
        // do nothing if showErrors is not set
        if (
          cfg.hasOwnProperty('showErrors') !== true ||
          cfg.showErrors === false
        ) {
          return;
        }

        var errorText = 'ChessBoard Error ' + code + ': ' + msg;

        // print to console
        if (
          cfg.showErrors === 'console' &&
          typeof console === 'object' &&
          typeof console.log === 'function'
        ) {
          console.log(errorText);
          if (arguments.length >= 2) {
            console.log(obj);
          }
          return;
        }

        // alert errors
        if (cfg.showErrors === 'alert') {
          if (obj) {
            errorText += '\n\n' + JSON.stringify(obj);
          }
          window.alert(errorText);
          return;
        }

        // custom function
        if (typeof cfg.showErrors === 'function') {
          cfg.showErrors(code, msg, obj);
        }
      }

      // check dependencies
      function checkDeps() {
        // if containerId is a string, it must be the ID of a DOM node
        if (typeof containerElOrId === 'string') {
          // cannot be empty
          if (containerElOrId === '') {
            window.alert(
              'ChessBoard Error 1001: ' +
                'The first argument to ChessBoard() cannot be an empty string.' +
                '\n\nExiting...',
            );
            return false;
          }

          // make sure the container element exists in the DOM
          var el = document.getElementById(containerElOrId);
          if (!el) {
            window.alert(
              'ChessBoard Error 1002: Element with id "' +
                containerElOrId +
                '" does not exist in the DOM.' +
                '\n\nExiting...',
            );
            return false;
          }

          // set the containerEl
          containerEl = $(el);
        }

        // else it must be something that becomes a jQuery collection
        // with size 1
        // ie: a single DOM node or jQuery object
        else {
          containerEl = $(containerElOrId);

          if (containerEl.length !== 1) {
            window.alert(
              'ChessBoard Error 1003: The first argument to ' +
                'ChessBoard() must be an ID or a single DOM node.' +
                '\n\nExiting...',
            );
            return false;
          }
        }

        // JSON must exist
        if (
          !window.JSON ||
          typeof JSON.stringify !== 'function' ||
          typeof JSON.parse !== 'function'
        ) {
          window.alert(
            'ChessBoard Error 1004: JSON does not exist. ' +
              'Please include a JSON polyfill.\n\nExiting...',
          );
          return false;
        }

        // check for a compatible version of jQuery
        if (
          !(
            typeof window.$ &&
            $.fn &&
            $.fn.jquery &&
            compareSemVer($.fn.jquery, MINIMUM_JQUERY_VERSION) === true
          )
        ) {
          window.alert(
            'ChessBoard Error 1005: Unable to find a valid version ' +
              'of jQuery. Please include jQuery ' +
              MINIMUM_JQUERY_VERSION +
              ' or ' +
              'higher on the page.\n\nExiting...',
          );
          return false;
        }

        return true;
      }

      function validAnimationSpeed(speed) {
        if (speed === 'fast' || speed === 'slow') {
          return true;
        }

        if (parseInt(speed, 10) + '' !== speed + '') {
          return false;
        }

        return speed >= 0;
      }

      // validate config / set default options
      function expandConfig() {
        if (typeof cfg === 'string' || validPositionObject(cfg) === true) {
          cfg = {
            position: cfg,
          };
        }

        // default for orientation is white
        if (cfg.orientation !== 'black') {
          cfg.orientation = 'white';
        }
        CURRENT_ORIENTATION = cfg.orientation;

        // default for showNotation is true
        if (cfg.showNotation !== false) {
          cfg.showNotation = true;
        }

        // default for draggable is false
        if (cfg.draggable !== true) {
          cfg.draggable = false;
        }

        // default for dropOffBoard is 'snapback'
        if (cfg.dropOffBoard !== 'trash') {
          cfg.dropOffBoard = 'snapback';
        }

        // default for sparePieces is false
        if (cfg.sparePieces !== true) {
          cfg.sparePieces = false;
        }

        // draggable must be true if sparePieces is enabled
        if (cfg.sparePieces === true) {
          cfg.draggable = true;
        }

        // default piece theme is wikipedia
        if (
          cfg.hasOwnProperty('pieceTheme') !== true ||
          (typeof cfg.pieceTheme !== 'string' &&
            typeof cfg.pieceTheme !== 'function')
        ) {
          cfg.pieceTheme = 'img/chesspieces/wikipedia/{piece}.png';
        }

        // animation speeds
        if (
          cfg.hasOwnProperty('appearSpeed') !== true ||
          validAnimationSpeed(cfg.appearSpeed) !== true
        ) {
          cfg.appearSpeed = 200;
        }
        if (
          cfg.hasOwnProperty('moveSpeed') !== true ||
          validAnimationSpeed(cfg.moveSpeed) !== true
        ) {
          cfg.moveSpeed = 200;
        }
        if (
          cfg.hasOwnProperty('snapbackSpeed') !== true ||
          validAnimationSpeed(cfg.snapbackSpeed) !== true
        ) {
          cfg.snapbackSpeed = 50;
        }
        if (
          cfg.hasOwnProperty('snapSpeed') !== true ||
          validAnimationSpeed(cfg.snapSpeed) !== true
        ) {
          cfg.snapSpeed = 25;
        }
        if (
          cfg.hasOwnProperty('trashSpeed') !== true ||
          validAnimationSpeed(cfg.trashSpeed) !== true
        ) {
          cfg.trashSpeed = 100;
        }

        // make sure position is valid
        if (cfg.hasOwnProperty('position') === true) {
          if (cfg.position === 'start') {
            CURRENT_POSITION = deepCopy(START_POSITION);
          } else if (validFen(cfg.position) === true) {
            CURRENT_POSITION = fenToObj(cfg.position);
          } else if (validPositionObject(cfg.position) === true) {
            CURRENT_POSITION = deepCopy(cfg.position);
          } else {
            error(
              7263,
              'Invalid value passed to config.position.',
              cfg.position,
            );
          }
        }

        return true;
      }

      //------------------------------------------------------------------------------
      // DOM Misc
      //------------------------------------------------------------------------------

      // calculates square size based on the width of the container
      // got a little CSS black magic here, so let me explain:
      // get the width of the container element (could be anything), reduce by 1 for
      // fudge factor, and then keep reducing until we find an exact mod 8 for
      // our square size
      function calculateSquareSize() {
        var containerWidth = parseInt(containerEl.width(), 10);

        // defensive, prevent infinite loop
        if (!containerWidth || containerWidth <= 0) {
          return 0;
        }

        // pad one pixel
        var boardWidth = containerWidth - 1;

        while (boardWidth % 8 !== 0 && boardWidth > 0) {
          boardWidth--;
        }

        return boardWidth / 8;
      }

      // create random IDs for elements
      function createElIds() {
        // squares on the board
        for (var i = 0; i < COLUMNS.length; i++) {
          for (var j = 1; j <= 8; j++) {
            var square = COLUMNS[i] + j;
            SQUARE_ELS_IDS[square] = square + '-' + uuid();
          }
        }

        // spare pieces
        var pieces = 'KQRBNP'.split('');
        for (var i = 0; i < pieces.length; i++) {
          var whitePiece = 'w' + pieces[i];
          var blackPiece = 'b' + pieces[i];
          SPARE_PIECE_ELS_IDS[whitePiece] = whitePiece + '-' + uuid();
          SPARE_PIECE_ELS_IDS[blackPiece] = blackPiece + '-' + uuid();
        }
      }

      //------------------------------------------------------------------------------
      // Markup Building
      //------------------------------------------------------------------------------

      function buildBoardContainer() {
        var html = '<div class="' + CSS.chessboard + '">';

        if (cfg.sparePieces === true) {
          html +=
            '<div class="' +
            CSS.sparePieces +
            ' ' +
            CSS.sparePiecesTop +
            '"></div>';
        }

        html += '<div class="' + CSS.board + '"></div>';

        if (cfg.sparePieces === true) {
          html +=
            '<div class="' +
            CSS.sparePieces +
            ' ' +
            CSS.sparePiecesBottom +
            '"></div>';
        }

        html += '</div>';

        return html;
      }

      /*
  	var buildSquare = function(color, size, id) {
  	  var html = '<div class="' + CSS.square + ' ' + CSS[color] + '" ' +
  	  'style="width: ' + size + 'px; height: ' + size + 'px" ' +
  	  'id="' + id + '">';

  	  if (cfg.showNotation === true) {

  	  }

  	  html += '</div>';

  	  return html;
  	};
  	*/

      function buildBoard(orientation) {
        if (orientation !== 'black') {
          orientation = 'white';
        }

        var html = '';

        // algebraic notation / orientation
        var alpha = deepCopy(COLUMNS);
        var row = 8;
        if (orientation === 'black') {
          alpha.reverse();
          row = 1;
        }

        var squareColor = 'white';
        for (var i = 0; i < 8; i++) {
          html += '<div class="' + CSS.row + '">';
          for (var j = 0; j < 8; j++) {
            var square = alpha[j] + row;

            html +=
              '<div class="' +
              CSS.square +
              ' ' +
              CSS[squareColor] +
              ' ' +
              'square-' +
              square +
              '" ' +
              'style="width: ' +
              SQUARE_SIZE +
              'px; height: ' +
              SQUARE_SIZE +
              'px" ' +
              'id="' +
              SQUARE_ELS_IDS[square] +
              '" ' +
              'data-square="' +
              square +
              '">';

            if (cfg.showNotation === true) {
              // alpha notation
              if (
                (orientation === 'white' && row === 1) ||
                (orientation === 'black' && row === 8)
              ) {
                html +=
                  '<div class="' +
                  CSS.notation +
                  ' ' +
                  CSS.alpha +
                  '">' +
                  alpha[j] +
                  '</div>';
              }

              // numeric notation
              if (j === 0) {
                html +=
                  '<div class="' +
                  CSS.notation +
                  ' ' +
                  CSS.numeric +
                  '">' +
                  row +
                  '</div>';
              }
            }

            html += '</div>'; // end .square

            squareColor = squareColor === 'white' ? 'black' : 'white';
          }
          html += '<div class="' + CSS.clearfix + '"></div></div>';

          squareColor = squareColor === 'white' ? 'black' : 'white';

          if (orientation === 'white') {
            row--;
          } else {
            row++;
          }
        }

        return html;
      }

      function buildPieceImgSrc(piece) {
        if (typeof cfg.pieceTheme === 'function') {
          return cfg.pieceTheme(piece);
        }

        if (typeof cfg.pieceTheme === 'string') {
          return cfg.pieceTheme.replace(/{piece}/g, piece);
        }

        // NOTE: this should never happen
        error(8272, 'Unable to build image source for cfg.pieceTheme.');
        return '';
      }

      function buildPiece(piece, hidden, id) {
        var html = '<img src="' + buildPieceImgSrc(piece) + '" ';
        if (id && typeof id === 'string') {
          html += 'id="' + id + '" ';
        }
        html +=
          'alt="" ' +
          'class="' +
          CSS.piece +
          '" ' +
          'data-piece="' +
          piece +
          '" ' +
          'style="width: ' +
          SQUARE_SIZE +
          'px;' +
          'height: ' +
          SQUARE_SIZE +
          'px;';
        if (hidden === true) {
          html += 'display:none;';
        }
        html += '" />';

        return html;
      }

      function buildSparePieces(color) {
        var pieces = ['wK', 'wQ', 'wR', 'wB', 'wN', 'wP'];
        if (color === 'black') {
          pieces = ['bK', 'bQ', 'bR', 'bB', 'bN', 'bP'];
        }

        var html = '';
        for (var i = 0; i < pieces.length; i++) {
          html += buildPiece(pieces[i], false, SPARE_PIECE_ELS_IDS[pieces[i]]);
        }

        return html;
      }

      //------------------------------------------------------------------------------
      // Animations
      //------------------------------------------------------------------------------

      function animateSquareToSquare(src, dest, piece, completeFn) {
        // get information about the source and destination squares
        var srcSquareEl = $('#' + SQUARE_ELS_IDS[src]);
        var srcSquarePosition = srcSquareEl.offset();
        var destSquareEl = $('#' + SQUARE_ELS_IDS[dest]);
        var destSquarePosition = destSquareEl.offset();

        // create the animated piece and absolutely position it
        // over the source square
        var animatedPieceId = uuid();
        $('body').append(buildPiece(piece, true, animatedPieceId));
        var animatedPieceEl = $('#' + animatedPieceId);
        animatedPieceEl.css({
          display: '',
          position: 'absolute',
          top: srcSquarePosition.top,
          left: srcSquarePosition.left,
        });

        // remove original piece from source square
        srcSquareEl.find('.' + CSS.piece).remove();

        // on complete
        var complete = function () {
          // add the "real" piece to the destination square
          destSquareEl.append(buildPiece(piece));

          // remove the animated piece
          animatedPieceEl.remove();

          // run complete function
          if (typeof completeFn === 'function') {
            completeFn();
          }
        };

        // animate the piece to the destination square
        var opts = {
          duration: cfg.moveSpeed,
          complete: complete,
        };
        animatedPieceEl.animate(destSquarePosition, opts);
      }

      function animateSparePieceToSquare(piece, dest, completeFn) {
        var srcOffset = $('#' + SPARE_PIECE_ELS_IDS[piece]).offset();
        var destSquareEl = $('#' + SQUARE_ELS_IDS[dest]);
        var destOffset = destSquareEl.offset();

        // create the animate piece
        var pieceId = uuid();
        $('body').append(buildPiece(piece, true, pieceId));
        var animatedPieceEl = $('#' + pieceId);
        animatedPieceEl.css({
          display: '',
          position: 'absolute',
          left: srcOffset.left,
          top: srcOffset.top,
        });

        // on complete
        var complete = function () {
          // add the "real" piece to the destination square
          destSquareEl.find('.' + CSS.piece).remove();
          destSquareEl.append(buildPiece(piece));

          // remove the animated piece
          animatedPieceEl.remove();

          // run complete function
          if (typeof completeFn === 'function') {
            completeFn();
          }
        };

        // animate the piece to the destination square
        var opts = {
          duration: cfg.moveSpeed,
          complete: complete,
        };
        animatedPieceEl.animate(destOffset, opts);
      }

      // execute an array of animations
      function doAnimations(a, oldPos, newPos) {
        if (a.length === 0) {
          return;
        }

        var numFinished = 0;
        function onFinish() {
          numFinished++;

          // exit if all the animations aren't finished
          if (numFinished !== a.length) return;

          drawPositionInstant();

          // run their onMoveEnd function
          if (
            cfg.hasOwnProperty('onMoveEnd') === true &&
            typeof cfg.onMoveEnd === 'function'
          ) {
            cfg.onMoveEnd(deepCopy(oldPos), deepCopy(newPos));
          }
        }

        for (var i = 0; i < a.length; i++) {
          // clear a piece
          if (a[i].type === 'clear') {
            $('#' + SQUARE_ELS_IDS[a[i].square] + ' .' + CSS.piece).fadeOut(
              cfg.trashSpeed,
              onFinish,
            );
          }

          // add a piece (no spare pieces)
          if (a[i].type === 'add' && cfg.sparePieces !== true) {
            $('#' + SQUARE_ELS_IDS[a[i].square])
              .append(buildPiece(a[i].piece, true))
              .find('.' + CSS.piece)
              .fadeIn(cfg.appearSpeed, onFinish);
          }

          // add a piece from a spare piece
          if (a[i].type === 'add' && cfg.sparePieces === true) {
            animateSparePieceToSquare(a[i].piece, a[i].square, onFinish);
          }

          // move a piece
          if (a[i].type === 'move') {
            animateSquareToSquare(
              a[i].source,
              a[i].destination,
              a[i].piece,
              onFinish,
            );
          }
        }
      }

      // returns the distance between two squares
      function squareDistance(s1, s2) {
        s1 = s1.split('');
        var s1x = COLUMNS.indexOf(s1[0]) + 1;
        var s1y = parseInt(s1[1], 10);

        s2 = s2.split('');
        var s2x = COLUMNS.indexOf(s2[0]) + 1;
        var s2y = parseInt(s2[1], 10);

        var xDelta = Math.abs(s1x - s2x);
        var yDelta = Math.abs(s1y - s2y);

        if (xDelta >= yDelta) return xDelta;
        return yDelta;
      }

      // returns an array of closest squares from square
      function createRadius(square) {
        var squares = [];

        // calculate distance of all squares
        for (var i = 0; i < 8; i++) {
          for (var j = 0; j < 8; j++) {
            var s = COLUMNS[i] + (j + 1);

            // skip the square we're starting from
            if (square === s) continue;

            squares.push({
              square: s,
              distance: squareDistance(square, s),
            });
          }
        }

        // sort by distance
        squares.sort(function (a, b) {
          return a.distance - b.distance;
        });

        // just return the square code
        var squares2 = [];
        for (var i = 0; i < squares.length; i++) {
          squares2.push(squares[i].square);
        }

        return squares2;
      }

      // returns the square of the closest instance of piece
      // returns false if no instance of piece is found in position
      function findClosestPiece(position, piece, square) {
        // create array of closest squares from square
        var closestSquares = createRadius(square);

        // search through the position in order of distance for the piece
        for (var i = 0; i < closestSquares.length; i++) {
          var s = closestSquares[i];

          if (position.hasOwnProperty(s) === true && position[s] === piece) {
            return s;
          }
        }

        return false;
      }

      // calculate an array of animations that need to happen in order to get
      // from pos1 to pos2
      function calculateAnimations(pos1, pos2) {
        // make copies of both
        pos1 = deepCopy(pos1);
        pos2 = deepCopy(pos2);

        var animations = [];
        var squaresMovedTo = {};

        // remove pieces that are the same in both positions
        for (var i in pos2) {
          if (pos2.hasOwnProperty(i) !== true) continue;

          if (pos1.hasOwnProperty(i) === true && pos1[i] === pos2[i]) {
            delete pos1[i];
            delete pos2[i];
          }
        }

        // find all the "move" animations
        for (var i in pos2) {
          if (pos2.hasOwnProperty(i) !== true) continue;

          var closestPiece = findClosestPiece(pos1, pos2[i], i);
          if (closestPiece !== false) {
            animations.push({
              type: 'move',
              source: closestPiece,
              destination: i,
              piece: pos2[i],
            });

            delete pos1[closestPiece];
            delete pos2[i];
            squaresMovedTo[i] = true;
          }
        }

        // add pieces to pos2
        for (var i in pos2) {
          if (pos2.hasOwnProperty(i) !== true) continue;

          animations.push({
            type: 'add',
            square: i,
            piece: pos2[i],
          });

          delete pos2[i];
        }

        // clear pieces from pos1
        for (var i in pos1) {
          if (pos1.hasOwnProperty(i) !== true) continue;

          // do not clear a piece if it is on a square that is the result
          // of a "move", ie: a piece capture
          if (squaresMovedTo.hasOwnProperty(i) === true) continue;

          animations.push({
            type: 'clear',
            square: i,
            piece: pos1[i],
          });

          delete pos1[i];
        }

        return animations;
      }

      //------------------------------------------------------------------------------
      // Control Flow
      //------------------------------------------------------------------------------

      function drawPositionInstant() {
        // clear the board
        boardEl.find('.' + CSS.piece).remove();

        // add the pieces
        for (var i in CURRENT_POSITION) {
          if (CURRENT_POSITION.hasOwnProperty(i) !== true) continue;

          $('#' + SQUARE_ELS_IDS[i]).append(buildPiece(CURRENT_POSITION[i]));
        }
      }

      function drawBoard() {
        boardEl.html(buildBoard(CURRENT_ORIENTATION));
        drawPositionInstant();

        if (cfg.sparePieces === true) {
          if (CURRENT_ORIENTATION === 'white') {
            sparePiecesTopEl.html(buildSparePieces('black'));
            sparePiecesBottomEl.html(buildSparePieces('white'));
          } else {
            sparePiecesTopEl.html(buildSparePieces('white'));
            sparePiecesBottomEl.html(buildSparePieces('black'));
          }
        }
      }

      // given a position and a set of moves, return a new position
      // with the moves executed
      function calculatePositionFromMoves(position, moves) {
        position = deepCopy(position);

        for (var i in moves) {
          if (moves.hasOwnProperty(i) !== true) continue;

          // skip the move if the position doesn't have a piece on the source square
          if (position.hasOwnProperty(i) !== true) continue;

          var piece = position[i];
          delete position[i];
          position[moves[i]] = piece;
        }

        return position;
      }

      function setCurrentPosition(position) {
        var oldPos = deepCopy(CURRENT_POSITION);
        var newPos = deepCopy(position);
        var oldFen = objToFen(oldPos);
        var newFen = objToFen(newPos);

        // do nothing if no change in position
        if (oldFen === newFen) return;

        // run their onChange function
        if (
          cfg.hasOwnProperty('onChange') === true &&
          typeof cfg.onChange === 'function'
        ) {
          cfg.onChange(oldPos, newPos);
        }

        // update state
        CURRENT_POSITION = position;
      }

      function isXYOnSquare(x, y) {
        for (var i in SQUARE_ELS_OFFSETS) {
          if (SQUARE_ELS_OFFSETS.hasOwnProperty(i) !== true) continue;

          var s = SQUARE_ELS_OFFSETS[i];
          if (
            x >= s.left &&
            x < s.left + SQUARE_SIZE &&
            y >= s.top &&
            y < s.top + SQUARE_SIZE
          ) {
            return i;
          }
        }

        return 'offboard';
      }

      // records the XY coords of every square into memory
      function captureSquareOffsets() {
        SQUARE_ELS_OFFSETS = {};

        for (var i in SQUARE_ELS_IDS) {
          if (SQUARE_ELS_IDS.hasOwnProperty(i) !== true) continue;

          SQUARE_ELS_OFFSETS[i] = $('#' + SQUARE_ELS_IDS[i]).offset();
        }
      }

      function removeSquareHighlights() {
        boardEl
          .find('.' + CSS.square)
          .removeClass(CSS.highlight1 + ' ' + CSS.highlight2);
      }

      function snapbackDraggedPiece() {
        // there is no "snapback" for spare pieces
        if (DRAGGED_PIECE_SOURCE === 'spare') {
          trashDraggedPiece();
          return;
        }

        removeSquareHighlights();

        // animation complete
        function complete() {
          drawPositionInstant();
          draggedPieceEl.css('display', 'none');

          // run their onSnapbackEnd function
          if (
            cfg.hasOwnProperty('onSnapbackEnd') === true &&
            typeof cfg.onSnapbackEnd === 'function'
          ) {
            cfg.onSnapbackEnd(
              DRAGGED_PIECE,
              DRAGGED_PIECE_SOURCE,
              deepCopy(CURRENT_POSITION),
              CURRENT_ORIENTATION,
            );
          }
        }

        // get source square position
        var sourceSquarePosition = $(
          '#' + SQUARE_ELS_IDS[DRAGGED_PIECE_SOURCE],
        ).offset();

        // animate the piece to the target square
        var opts = {
          duration: cfg.snapbackSpeed,
          complete: complete,
        };
        draggedPieceEl.animate(sourceSquarePosition, opts);

        // set state
        DRAGGING_A_PIECE = false;
      }

      function trashDraggedPiece() {
        removeSquareHighlights();

        // remove the source piece
        var newPosition = deepCopy(CURRENT_POSITION);
        delete newPosition[DRAGGED_PIECE_SOURCE];
        setCurrentPosition(newPosition);

        // redraw the position
        drawPositionInstant();

        // hide the dragged piece
        draggedPieceEl.fadeOut(cfg.trashSpeed);

        // set state
        DRAGGING_A_PIECE = false;
      }

      function dropDraggedPieceOnSquare(square) {
        removeSquareHighlights();

        // update position
        var newPosition = deepCopy(CURRENT_POSITION);
        delete newPosition[DRAGGED_PIECE_SOURCE];
        newPosition[square] = DRAGGED_PIECE;
        setCurrentPosition(newPosition);

        // get target square information
        var targetSquarePosition = $('#' + SQUARE_ELS_IDS[square]).offset();

        // animation complete
        var complete = function () {
          drawPositionInstant();
          draggedPieceEl.css('display', 'none');

          // execute their onSnapEnd function
          if (
            cfg.hasOwnProperty('onSnapEnd') === true &&
            typeof cfg.onSnapEnd === 'function'
          ) {
            cfg.onSnapEnd(DRAGGED_PIECE_SOURCE, square, DRAGGED_PIECE);
          }
        };

        // snap the piece to the target square
        var opts = {
          duration: cfg.snapSpeed,
          complete: complete,
        };
        draggedPieceEl.animate(targetSquarePosition, opts);

        // set state
        DRAGGING_A_PIECE = false;
      }

      function beginDraggingPiece(source, piece, x, y) {
        // run their custom onDragStart function
        // their custom onDragStart function can cancel drag start
        if (
          typeof cfg.onDragStart === 'function' &&
          cfg.onDragStart(
            source,
            piece,
            deepCopy(CURRENT_POSITION),
            CURRENT_ORIENTATION,
          ) === false
        ) {
          return;
        }

        // set state
        DRAGGING_A_PIECE = true;
        DRAGGED_PIECE = piece;
        DRAGGED_PIECE_SOURCE = source;

        // if the piece came from spare pieces, location is offboard
        if (source === 'spare') {
          DRAGGED_PIECE_LOCATION = 'offboard';
        } else {
          DRAGGED_PIECE_LOCATION = source;
        }

        // capture the x, y coords of all squares in memory
        captureSquareOffsets();

        // create the dragged piece
        draggedPieceEl.attr('src', buildPieceImgSrc(piece)).css({
          display: '',
          position: 'absolute',
          left: x - SQUARE_SIZE / 2,
          top: y - SQUARE_SIZE / 2,
        });

        if (source !== 'spare') {
          // highlight the source square and hide the piece
          $('#' + SQUARE_ELS_IDS[source])
            .addClass(CSS.highlight1)
            .find('.' + CSS.piece)
            .css('display', 'none');
        }
      }

      function updateDraggedPiece(x, y) {
        // put the dragged piece over the mouse cursor
        draggedPieceEl.css({
          left: x - SQUARE_SIZE / 2,
          top: y - SQUARE_SIZE / 2,
        });

        // get location
        var location = isXYOnSquare(x, y);

        // do nothing if the location has not changed
        if (location === DRAGGED_PIECE_LOCATION) return;

        // remove highlight from previous square
        if (validSquare(DRAGGED_PIECE_LOCATION) === true) {
          $('#' + SQUARE_ELS_IDS[DRAGGED_PIECE_LOCATION]).removeClass(
            CSS.highlight2,
          );
        }

        // add highlight to new square
        if (validSquare(location) === true) {
          $('#' + SQUARE_ELS_IDS[location]).addClass(CSS.highlight2);
        }

        // run onDragMove
        if (typeof cfg.onDragMove === 'function') {
          cfg.onDragMove(
            location,
            DRAGGED_PIECE_LOCATION,
            DRAGGED_PIECE_SOURCE,
            DRAGGED_PIECE,
            deepCopy(CURRENT_POSITION),
            CURRENT_ORIENTATION,
          );
        }

        // update state
        DRAGGED_PIECE_LOCATION = location;
      }

      function stopDraggedPiece(location) {
        // determine what the action should be
        var action = 'drop';
        if (location === 'offboard' && cfg.dropOffBoard === 'snapback') {
          action = 'snapback';
        }
        if (location === 'offboard' && cfg.dropOffBoard === 'trash') {
          action = 'trash';
        }

        // run their onDrop function, which can potentially change the drop action
        if (
          cfg.hasOwnProperty('onDrop') === true &&
          typeof cfg.onDrop === 'function'
        ) {
          var newPosition = deepCopy(CURRENT_POSITION);

          // source piece is a spare piece and position is off the board
          //if (DRAGGED_PIECE_SOURCE === 'spare' && location === 'offboard') {...}
          // position has not changed; do nothing

          // source piece is a spare piece and position is on the board
          if (
            DRAGGED_PIECE_SOURCE === 'spare' &&
            validSquare(location) === true
          ) {
            // add the piece to the board
            newPosition[location] = DRAGGED_PIECE;
          }

          // source piece was on the board and position is off the board
          if (
            validSquare(DRAGGED_PIECE_SOURCE) === true &&
            location === 'offboard'
          ) {
            // remove the piece from the board
            delete newPosition[DRAGGED_PIECE_SOURCE];
          }

          // source piece was on the board and position is on the board
          if (
            validSquare(DRAGGED_PIECE_SOURCE) === true &&
            validSquare(location) === true
          ) {
            // move the piece
            delete newPosition[DRAGGED_PIECE_SOURCE];
            newPosition[location] = DRAGGED_PIECE;
          }

          var oldPosition = deepCopy(CURRENT_POSITION);

          var result = cfg.onDrop(
            DRAGGED_PIECE_SOURCE,
            location,
            DRAGGED_PIECE,
            newPosition,
            oldPosition,
            CURRENT_ORIENTATION,
          );
          if (result === 'snapback' || result === 'trash') {
            action = result;
          }
        }

        // do it!
        if (action === 'snapback') {
          snapbackDraggedPiece();
        } else if (action === 'trash') {
          trashDraggedPiece();
        } else if (action === 'drop') {
          dropDraggedPieceOnSquare(location);
        }
      }

      //------------------------------------------------------------------------------
      // Public Methods
      //------------------------------------------------------------------------------

      // clear the board
      widget.clear = function (useAnimation) {
        widget.position({}, useAnimation);
      };

      // remove the widget from the page
      widget.destroy = function () {
        // remove markup
        containerEl.html('');
        draggedPieceEl.remove();

        // remove event handlers
        containerEl.unbind();
      };

      // shorthand method to get the current FEN
      widget.fen = function () {
        return widget.position('fen');
      };

      // flip orientation
      widget.flip = function () {
        return widget.orientation('flip');
      };

      /*
  	// TODO: write this, GitHub Issue #5
  	widget.highlight = function() {

  	};
  	*/

      // move pieces
      widget.move = function () {
        // no need to throw an error here; just do nothing
        if (arguments.length === 0) return;

        var useAnimation = true;

        // collect the moves into an object
        var moves = {};
        for (var i = 0; i < arguments.length; i++) {
          // any "false" to this function means no animations
          if (arguments[i] === false) {
            useAnimation = false;
            continue;
          }

          // skip invalid arguments
          if (validMove(arguments[i]) !== true) {
            error(
              2826,
              'Invalid move passed to the move method.',
              arguments[i],
            );
            continue;
          }

          var tmp = arguments[i].split('-');
          moves[tmp[0]] = tmp[1];
        }

        // calculate position from moves
        var newPos = calculatePositionFromMoves(CURRENT_POSITION, moves);

        // update the board
        widget.position(newPos, useAnimation);

        // return the new position object
        return newPos;
      };

      widget.orientation = function (arg) {
        // no arguments, return the current orientation
        if (arguments.length === 0) {
          return CURRENT_ORIENTATION;
        }

        // set to white or black
        if (arg === 'white' || arg === 'black') {
          CURRENT_ORIENTATION = arg;
          drawBoard();
          return CURRENT_ORIENTATION;
        }

        // flip orientation
        if (arg === 'flip') {
          CURRENT_ORIENTATION =
            CURRENT_ORIENTATION === 'white' ? 'black' : 'white';
          drawBoard();
          return CURRENT_ORIENTATION;
        }

        error(5482, 'Invalid value passed to the orientation method.', arg);
      };

      widget.position = function (position, useAnimation) {
        // no arguments, return the current position
        if (arguments.length === 0) {
          return deepCopy(CURRENT_POSITION);
        }

        // get position as FEN
        if (typeof position === 'string' && position.toLowerCase() === 'fen') {
          return objToFen(CURRENT_POSITION);
        }

        // default for useAnimations is true
        if (useAnimation !== false) {
          useAnimation = true;
        }

        // start position
        if (
          typeof position === 'string' &&
          position.toLowerCase() === 'start'
        ) {
          position = deepCopy(START_POSITION);
        }

        // convert FEN to position object
        if (validFen(position) === true) {
          position = fenToObj(position);
        }

        // validate position object
        if (validPositionObject(position) !== true) {
          error(6482, 'Invalid value passed to the position method.', position);
          return;
        }

        if (useAnimation === true) {
          // start the animations
          doAnimations(
            calculateAnimations(CURRENT_POSITION, position),
            CURRENT_POSITION,
            position,
          );

          // set the new position
          setCurrentPosition(position);
        }
        // instant update
        else {
          setCurrentPosition(position);
          drawPositionInstant();
        }
      };

      widget.resize = function () {
        // calulate the new square size
        SQUARE_SIZE = calculateSquareSize();

        // set board width
        boardEl.css('width', SQUARE_SIZE * 8 + 'px');

        // set drag piece size
        draggedPieceEl.css({
          height: SQUARE_SIZE,
          width: SQUARE_SIZE,
        });

        // spare pieces
        if (cfg.sparePieces === true) {
          containerEl
            .find('.' + CSS.sparePieces)
            .css('paddingLeft', SQUARE_SIZE + BOARD_BORDER_SIZE + 'px');
        }

        // redraw the board
        drawBoard();
      };

      // set the starting position
      widget.start = function (useAnimation) {
        widget.position('start', useAnimation);
      };

      //------------------------------------------------------------------------------
      // Browser Events
      //------------------------------------------------------------------------------

      function isTouchDevice() {
        return 'ontouchstart' in document.documentElement;
      }

      // reference: http://www.quirksmode.org/js/detect.html
      function isMSIE() {
        return (
          navigator &&
          navigator.userAgent &&
          navigator.userAgent.search(/MSIE/) !== -1
        );
      }

      function stopDefault(e) {
        e.preventDefault();
      }

      function mousedownSquare(e) {
        // do nothing if we're not draggable
        if (cfg.draggable !== true) return;

        var square = $(this).attr('data-square');

        // no piece on this square
        if (
          validSquare(square) !== true ||
          CURRENT_POSITION.hasOwnProperty(square) !== true
        ) {
          return;
        }

        beginDraggingPiece(square, CURRENT_POSITION[square], e.pageX, e.pageY);
      }

      function touchstartSquare(e) {
        // do nothing if we're not draggable
        if (cfg.draggable !== true) return;

        var square = $(this).attr('data-square');

        // no piece on this square
        if (
          validSquare(square) !== true ||
          CURRENT_POSITION.hasOwnProperty(square) !== true
        ) {
          return;
        }

        e = e.originalEvent;
        beginDraggingPiece(
          square,
          CURRENT_POSITION[square],
          e.changedTouches[0].pageX,
          e.changedTouches[0].pageY,
        );
      }

      function mousedownSparePiece(e) {
        // do nothing if sparePieces is not enabled
        if (cfg.sparePieces !== true) return;

        var piece = $(this).attr('data-piece');

        beginDraggingPiece('spare', piece, e.pageX, e.pageY);
      }

      function touchstartSparePiece(e) {
        // do nothing if sparePieces is not enabled
        if (cfg.sparePieces !== true) return;

        var piece = $(this).attr('data-piece');

        e = e.originalEvent;
        beginDraggingPiece(
          'spare',
          piece,
          e.changedTouches[0].pageX,
          e.changedTouches[0].pageY,
        );
      }

      function mousemoveWindow(e) {
        // do nothing if we are not dragging a piece
        if (DRAGGING_A_PIECE !== true) return;

        updateDraggedPiece(e.pageX, e.pageY);
      }

      function touchmoveWindow(e) {
        // do nothing if we are not dragging a piece
        if (DRAGGING_A_PIECE !== true) return;

        // prevent screen from scrolling
        e.preventDefault();

        updateDraggedPiece(
          e.originalEvent.changedTouches[0].pageX,
          e.originalEvent.changedTouches[0].pageY,
        );
      }

      function mouseupWindow(e) {
        // do nothing if we are not dragging a piece
        if (DRAGGING_A_PIECE !== true) return;

        // get the location
        var location = isXYOnSquare(e.pageX, e.pageY);

        stopDraggedPiece(location);
      }

      function touchendWindow(e) {
        // do nothing if we are not dragging a piece
        if (DRAGGING_A_PIECE !== true) return;

        // get the location
        var location = isXYOnSquare(
          e.originalEvent.changedTouches[0].pageX,
          e.originalEvent.changedTouches[0].pageY,
        );

        stopDraggedPiece(location);
      }

      function mouseenterSquare(e) {
        // do not fire this event if we are dragging a piece
        // NOTE: this should never happen, but it's a safeguard
        if (DRAGGING_A_PIECE !== false) return;

        if (
          cfg.hasOwnProperty('onMouseoverSquare') !== true ||
          typeof cfg.onMouseoverSquare !== 'function'
        )
          return;

        // get the square
        var square = $(e.currentTarget).attr('data-square');

        // NOTE: this should never happen; defensive
        if (validSquare(square) !== true) return;

        // get the piece on this square
        var piece = false;
        if (CURRENT_POSITION.hasOwnProperty(square) === true) {
          piece = CURRENT_POSITION[square];
        }

        // execute their function
        cfg.onMouseoverSquare(
          square,
          piece,
          deepCopy(CURRENT_POSITION),
          CURRENT_ORIENTATION,
        );
      }

      function mouseleaveSquare(e) {
        // do not fire this event if we are dragging a piece
        // NOTE: this should never happen, but it's a safeguard
        if (DRAGGING_A_PIECE !== false) return;

        if (
          cfg.hasOwnProperty('onMouseoutSquare') !== true ||
          typeof cfg.onMouseoutSquare !== 'function'
        )
          return;

        // get the square
        var square = $(e.currentTarget).attr('data-square');

        // NOTE: this should never happen; defensive
        if (validSquare(square) !== true) return;

        // get the piece on this square
        var piece = false;
        if (CURRENT_POSITION.hasOwnProperty(square) === true) {
          piece = CURRENT_POSITION[square];
        }

        // execute their function
        cfg.onMouseoutSquare(
          square,
          piece,
          deepCopy(CURRENT_POSITION),
          CURRENT_ORIENTATION,
        );
      }

      //------------------------------------------------------------------------------
      // Initialization
      //------------------------------------------------------------------------------

      function addEvents() {
        // prevent browser "image drag"
        $('body').on('mousedown mousemove', '.' + CSS.piece, stopDefault);

        // mouse drag pieces
        boardEl.on('mousedown', '.' + CSS.square, mousedownSquare);
        containerEl.on(
          'mousedown',
          '.' + CSS.sparePieces + ' .' + CSS.piece,
          mousedownSparePiece,
        );

        // mouse enter / leave square
        boardEl
          .on('mouseenter', '.' + CSS.square, mouseenterSquare)
          .on('mouseleave', '.' + CSS.square, mouseleaveSquare);

        // IE doesn't like the events on the window object, but other browsers
        // perform better that way
        if (isMSIE() === true) {
          // IE-specific prevent browser "image drag"
          document.ondragstart = function () {
            return false;
          };

          $('body')
            .on('mousemove', mousemoveWindow)
            .on('mouseup', mouseupWindow);
        } else {
          $(window)
            .on('mousemove', mousemoveWindow)
            .on('mouseup', mouseupWindow);
        }

        // touch drag pieces
        if (isTouchDevice() === true) {
          boardEl.on('touchstart', '.' + CSS.square, touchstartSquare);
          containerEl.on(
            'touchstart',
            '.' + CSS.sparePieces + ' .' + CSS.piece,
            touchstartSparePiece,
          );
          $(window)
            .on('touchmove', touchmoveWindow)
            .on('touchend', touchendWindow);
        }
      }

      function initDom() {
        // create unique IDs for all the elements we will create
        createElIds();

        // build board and save it in memory
        containerEl.html(buildBoardContainer());
        boardEl = containerEl.find('.' + CSS.board);

        if (cfg.sparePieces === true) {
          sparePiecesTopEl = containerEl.find('.' + CSS.sparePiecesTop);
          sparePiecesBottomEl = containerEl.find('.' + CSS.sparePiecesBottom);
        }

        // create the drag piece
        var draggedPieceId = uuid();
        $('body').append(buildPiece('wP', true, draggedPieceId));
        draggedPieceEl = $('#' + draggedPieceId);

        // get the border size
        BOARD_BORDER_SIZE = parseInt(boardEl.css('borderLeftWidth'), 10);

        // set the size and draw the board
        widget.resize();
      }

      function init() {
        if (checkDeps() !== true || expandConfig() !== true) return;

        initDom();
        addEvents();
      }

      // go time
      init();

      // return the widget object
      return widget;
    }; // end window.ChessBoard

    // expose util functions
    ChessBoard.fenToObj = fenToObj;
    ChessBoard.objToFen = objToFen;

    chessboard = ChessBoard;
    return chessboard;
  }

  var chessboardExports = requireChessboard();
  var ChessboardImport =
    /*@__PURE__*/ getDefaultExportFromCjs(chessboardExports);

  /**
   * @module ui
   * Thin wrapper for chessboard.js mounting and event binding.
   */
  // Ensure the global (your existing code expects window.Chessboard)
  if (typeof window !== 'undefined' && !window.Chessboard) {
    window.Chessboard = ChessboardImport;
  }
  function mountBoard(boardEl, opts) {
    const Chessboard = window.Chessboard;
    if (typeof Chessboard !== 'function')
      throw new Error('chessboard.js global not found');
    const handle = Chessboard(boardEl, {
      position: opts.fen === 'start' ? 'start' : opts.fen,
      draggable: true,
      pieceTheme: opts.pieceTheme,
      moveSpeed: opts.speeds?.move ?? 150,
      snapbackSpeed: opts.speeds?.snapback ?? 120,
      trashSpeed: opts.speeds?.trash ?? 80,
      onDrop: opts.onDrop,
      onSnapEnd: () =>
        handle.position(opts.fen === 'start' ? 'start' : opts.fen),
    });
    return {
      position: (fen) => handle.position(fen === 'start' ? 'start' : fen),
    };
  }

  /**
   * @module feedback
   * Visuals: flash/arrow + progress + move list (numbers; future hidden)
   */
  function createFeedback(root) {
    const wrap = root.querySelector('#board-wrap');
    const anno = root.querySelector('#anno');
    const pb = root.querySelector('#progress-bar');
    const pt = root.querySelector('#progress-text');
    const ml = root.querySelector('#move-list');
    ensureAnnoDefs();
    function ensureAnnoDefs() {
      if (!anno) return;
      if (anno.querySelector('marker#arrowhead')) return;
      const defs = document.createElementNS(
        'http://www.w3.org/2000/svg',
        'defs',
      );
      const marker = document.createElementNS(
        'http://www.w3.org/2000/svg',
        'marker',
      );
      marker.setAttribute('id', 'arrowhead');
      marker.setAttribute('orient', 'auto');
      marker.setAttribute('markerWidth', '8');
      marker.setAttribute('markerHeight', '8');
      marker.setAttribute('refX', '2');
      marker.setAttribute('refY', '2');
      const path = document.createElementNS(
        'http://www.w3.org/2000/svg',
        'path',
      );
      path.setAttribute('d', 'M0,0 L4,2 L0,4 z');
      defs.appendChild(marker);
      marker.appendChild(path);
      anno.appendChild(defs);
    }
    function clearAnno() {
      if (!anno) return;
      const kids = Array.from(anno.children).filter(
        (n) => n.tagName !== 'defs',
      );
      kids.forEach((n) => n.remove());
    }
    function sqRect(sq, size) {
      const file = sq.charCodeAt(0) - 97;
      const rank = 8 - parseInt(sq[1], 10);
      const s = size / 8;
      return {
        x: file * s,
        y: rank * s,
        w: s,
        h: s,
        cx: (file + 0.5) * s,
        cy: (rank + 0.5) * s,
      };
    }
    function drawHint(from, to) {
      if (!anno || !from || !to) return;
      clearAnno();
      const size = wrap?.clientWidth ?? 340;
      const a = sqRect(from, size),
        b = sqRect(to, size);
      const r1 = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      r1.setAttribute('class', 'hint-from');
      r1.setAttribute('x', String(a.x));
      r1.setAttribute('y', String(a.y));
      r1.setAttribute('width', String(a.w));
      r1.setAttribute('height', String(a.h));
      const r2 = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      r2.setAttribute('class', 'hint-to');
      r2.setAttribute('x', String(b.x));
      r2.setAttribute('y', String(b.y));
      r2.setAttribute('width', String(b.w));
      r2.setAttribute('height', String(b.h));
      const line = document.createElementNS(
        'http://www.w3.org/2000/svg',
        'line',
      );
      line.setAttribute('class', 'hint');
      line.setAttribute('x1', String(a.cx));
      line.setAttribute('y1', String(a.cy));
      line.setAttribute('x2', String(b.cx));
      line.setAttribute('y2', String(b.cy));
      line.setAttribute('marker-end', 'url(#arrowhead)');
      anno.appendChild(r1);
      anno.appendChild(r2);
      anno.appendChild(line);
    }
    return {
      flashWrong(from, to) {
        if (wrap) {
          wrap.classList.add('flash-wrong', 'flash-anim');
          setTimeout(
            () => wrap.classList.remove('flash-wrong', 'flash-anim'),
            450,
          );
        }
        drawHint(from, to);
      },
      progress(step, total) {
        if (pb) {
          pb.max = total;
          pb.value = step;
        }
        if (pt) {
          pt.textContent = `Move ${Math.min(step + 1, total)} of ${total}`;
        }
      },
      listPlayed(san, step) {
        if (!ml) return;
        let html = '';
        for (let i = 0; i < step; i++) {
          if (i % 2 === 0)
            html += `<span style="color:#888;">${((i / 2) | 0) + 1}. </span>`;
          html += `<span style="color:#333;">${san[i]}</span> `;
        }
        if (step < san.length) {
          if (step % 2 === 0)
            html += `<span style="color:#888;">${((step / 2) | 0) + 1}. </span>`;
          html += `<span style="color:#1976d2;font-weight:700;">&#8226;&#8226;&#8226;</span>`;
        }
        ml.innerHTML = html.trim();
      },
      clearAnno,
    };
  }

  /**
   * @module scheduler
   * Auto-answer bridge to Anki via pycmd, guarded to run once.
   */
  function createScheduler({ autoAnswer = true }) {
    let answered = false;
    function fail() {
      if (autoAnswer && typeof window.pycmd === 'function' && !answered) {
        answered = true;
        setTimeout(() => {
          try {
            window.pycmd('fail_line');
          } catch {
            /* noop */
          }
        }, 0);
      }
    }
    function pass() {
      if (autoAnswer && typeof window.pycmd === 'function' && !answered) {
        answered = true;
        try {
          window.pycmd('pass_line');
        } catch {
          /* noop */
        }
      }
    }
    return { fail, pass };
  }

  var bK =
    'data:image/png;base64,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';

  var bQ =
    'data:image/png;base64,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';

  var bR =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAE5klEQVR42u2bTW8bRRjHvbbj3cT2eu3ETuw4Tp04bZoABoWAq9KGJG6o1KoQqIRQADsKqEigfgQORW2EFMQhl0aVIgTiSC6oQT0gtcixUkTbqBJISFA4ID5E/TLMrGeTzdYlu6T1zFPmLz2ayc7MzjO/zO68rV0uISEhISEhISEhISEhISEhIWjqjXc7LpNM9DxRDPqxIbuW6Ilp1htEO8OrdstHOyOr1vL0nrbKS5Ie9nNDrzOipRwBjDcDGFmxW76rM7xiLR93AJAY9ZkPvTCWdQQw3qQHUigtAzj+3DP8ACzOnd03wP33wKgmSZJtH4pzs/wARAh5nQDE7zu1SQ+87ADg5SavEdWJD9RnrmTb+ZP5lz579dTUxddOTX+C7cLrZ058nOqN37FbPpWM3yFlSFl6nwsn88c+deIDd8Ow1+Ox63jdYUOdmK17U1/5UkgNoMcI5pGaGvTzBzCZ6AYDEE/C+QN4INX7NxSA2Ne/eFyNrEABSH3lS3gOBgYg9ZUv4XnYlcc8wj6ykToSDl3hCt6hTNqVG8+SlUClBVOVfU1xiI+557Ma8Zk7DWUOSHiV8L2TJVUrjfh2MJOWuN3TinZF9BD/h0/joMJJTyQ+VI6MP3va7CP3yk/kegIB/8/mxlSrVVSvVfWQWK1WQzUaGtcMq9dxWCFhDVUqFT0PIteqjTi5T42YqUytel8PzXUGA/5fpo/n4O2+GrvMHrf7NmmIBy+fnKher+8KrfF/k9fr1eG5G3X/px1vboTBlUhjFEVBrRKpi655S+D3+rtjXY3G4F6xsLCAisWiyQq6FQrE3kXzOD6Pr5O4nlYobIdGnqKe3shXNPLRayRO6vDQjQ1aN2wpisxsAKF1gxfrURiuflj/Msoa4PWrX0TBApyeODLJGuArk0cnwQLEczDmAKkPMCXLvhOsAWIf8mABjgxnllgDHD2c+RwswLCmLrMGSH2Ap/Pn3iGbrMwBEh8+en8OZg/UQsE11gBDavAbsI+wpga3OHiEtyBvJDAHSH2AKfz+ucvBO/Au4FE4xHwbPxIOwV0Py7425gCpD2In5n+3I/Prj1fDvACkvsDSzNTRs7wApL7AEp7AvsELQOoLOM1y9A6cBUdvdDizxgvAkeHBNXAAI2HtmtGAxUsXUblcRhsbG7oZ8bLl711ppjyNfKXGtVJpJ6+RVio9cI/FxUvmueA1aNtYJFg3GrC5ufnQw/KHHZg3O1Df67DdnH7z5qa5F65rmso/uKdHDuphojs25nG7jS+10J9//IZarXv3ft8G6Ma+JOOxMbOPfM6aEXJlBlIP/Obtxo3r249bubxHaLWyzTyWdFKn1Y+hgf5V4iNX+mD+TT0cTPcFtJDK/depeEqDBtOpgNl35sqODs+4+P2wsumHltnRQzNcwEv1Jb6jH1RCgLcN0eNxo2Rvz7cc7Lj4ECBw1iNPxHzQgArPtfOjQ3YAJ4/n8tABTh17kenB+wR0gJLkepnlencJOsCnDg8tMYH34XtvuTralWXoABVFXj5/7m02PTDgb/8aOkB/R/tXzB5hv799CzrAgL9ji+Ugcgs6QGw/MaMX64rox4aKLCMyoSa2O+7T042/d6xNn8Qa8ablZV+TcnuUN67JdutvQ1HcBibwBtN9/P7mzKEyA6knpi1CQkJCQkJCQjb1DwnxQ/I2LRu/AAAAAElFTkSuQmCC';

  var bB =
    'data:image/png;base64,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';

  var bN =
    'data:image/png;base64,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';

  var bP =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAE1UlEQVR42u2bS2wbRRjHx5vY3oftJH47fsXxq17HJrYbh6QprZqmChENNFAhQQmkTWigtMGUqEh9cEkKQaKIh4QqFQlUcStVqYSioOaABJcieqJCHCiFnipVXHrGy8zWdW1TGuxdp7s785c+jdfr/db6+Zv5Zr5ZA0BERERERERERERERERERESkdr1V2P+v9+bnZgiYBykcCojtjm2bxk0cd9FiNv1OUdR1Sqe7bjabfjNz7NdPjg2Po88k4mECrFZDj+Z4jmV+hi+FBxn6zOMjjyUIsQoN5DOH1wJXYUXUQuCvEXJQg/nMq3XAq7KhgdzL2IIbHdkC9k3uDre0tAiNAtS3tgoH978QHt2+GU+IdlvHj3e7ZINW7Gi3/IAlvDOfnPRLAFdln3+65McOYLY3eU4ugLmM6AsvwbHvklwA9Xr9JewAOuzWP+QCWPKFWQKxW6/JCPAaVvAOzU7CLkytSMzA5UzcQlErhQMv4RWBvanEe3JFYMkXXhIEgdbpdJLhUZROQL6wnAu2t1m+kTqRLvnAT89OjIktx7INR1/p2rIvPIsJ/dmswaCvGx66ZmhgYxbrSkyn2ym23V3+q/UCDIcCVyt9YCeYOcH7i0fsRoPhSoPjYNFoNF5ZevuwNZPm8QMIM7DDZOIEqUnEjHxQwIEFtP6+R8R25+i2UYNeLxVeRSQaBOQT+e7LprQJz+20i21fLrVPjvlfrSGfud6kuBxxu+zagnd0/hWxdTlsq6BiX0NmE326nOI9wJGCRqr91o42tOqgPC7H7SbCq4Fovy0IRQrdW9UKBX3gzYPTaAvyRpPB3Q/kjflD07HukIqL1UG/Nw+nKcI6w6tKLkGfJ69KeHsnn3GwDHMWvvx4LYOrigsNrEQu/B/fHMeeRd9F09Mbn9e9u16AcEydAETlJV3dEejtdJ0n5EryuJ11j3EBf6dAyEFNPT/R02iimJ+b6cEa3tzsJAj4PHsbBRiLdE0tHi/gHYFmE3e+UYA2a/tXWMODKxQdnGY0PNdjWRrfcXBi5w4Qi3bNSJ0wZ9L81IGZPdh23++krjbaLOZVbKOwVcKzgaD8XEwrnt04FPStyrVGjkVC32IH0MRxshUNOJbBKwrdLsdPcldfvB7X5R4+pn146WTM26ySfrS7y6NZcInYnT/H0LSxaSV9ttSVNReJu54YQZNm4LBZb4EmF1JdTvstdK+n4D01oe1bByG8v6nkhuivYH0q00V+Q+QXtMoZ3jKgDYjxaOgvsM57IvGIeE916sOlY2K7cLwQpijqJnhIeyIwsdxcOPa6OPh++dkpdUEMBrzvPARo9zW/z3NCFdDGx4bFlmGMl0Hz94Dr2itus5jQdwLJRFSZ8Ph4RGxt1vY/lRJ5tWY0GtBfy9CTscqCh8aX5YtfwOUZ+71S4ZVriAy9gjK04iIwxcdmFdJl1+zSAb9HWVuipz9aYGC2FVQAr9SVjejJfmXAWzzxBhqYR1QSfWXj4+GhD949qgyIWzf3n1QTPGTwR59WTBfuTfPn1AZwY6ZHOX+R7cumCUBpAFMqBJhSDsBN/dllGma2KqPvGENXHFecY2qOUcvQdM3xf5wvnWPoe/e59z5ddS1Tc+7u+cF8ZlkR8Kb2PK3aoseLz+0CRERERERERESY6h+RAfZINhLK1wAAAABJRU5ErkJggg==';

  var wK =
    'data:image/png;base64,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';

  var wQ =
    'data:image/png;base64,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';

  var wR =
    'data:image/png;base64,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';

  var wB =
    'data:image/png;base64,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';

  var wN =
    'data:image/png;base64,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';

  var wP =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAHE0lEQVR42u2bfUwTZxzHry2012sF+kp5aQVaKEVQeZGCIjAIRs10m1uGJrpVnZpNp9aXGYczagYme3F/LBqTxWRmWRYQzViyOJf1jyWLM2zRqGxqBk5HcJkaM2KcLwl9dr/jnuN6gLQg2vaeb/Lkjt7z/J7nPvye9+coioiIiIiIiIiIiIiIiIiIiCjWtWPz2rB+IxIpJ9vBXefVzV2s1+m+0euYq0ql4hoEuNczTMcLC+sXQxyP20mASTVntrdAq6W72Fv0uKBjtF0LGqo9hJhIleXFW0eCpVAo2DDs9yBFKdCcipINhByrivLSt8SAbDYbamlpRv39/Qirv/9ftG/fXmS1WkNgVlWWyrdhnN9QQ631NTpVKqUApL6+ngMWDAa5gO/F15qaaiF+YkIC2rDuNefCebXyhGg0pHQOVkkK1dXVhYAaSfhZbW2NUJ2NhuQzsoR35OB+O/Ykq9UyJjwpRHF1Pnr4Q7vsAJbMnNaOAWzbtjUseGJt2eIXAPK25CWVShXAAK5cuYwiFaTB6RMGbclLZrPxOgYwXuH0lkFb8hL70n9iAMHgQMTwggMDAkCzyXBVVvD27NxIKZXK73APPK4qfFmowkGVUnnKv94nLw+cWeT5AHvQrqadkXkf2+E0NTUJHsjbkpdYDjRM1eDWbrcPG6Y8bggDgjR4uge2ZDkWTElO+hZX48bGV9HAwNhtIcRZurRRqL68DfmpcclC7jpFrxOqYnV19YjeJr4XT+V0jBaJbclSVZVlJYmJCQIUtVqNvN5ydPPmTQHarVu3UAX7GzwT5sFsmjkVpSWyXolJt1m5a3aW4zfxKksg8MOwqhsIBEJWYrKnZkIaKjPdJk947PSL+uj9d4wajfosbgcZhkF9fX2jVmF4ptMJVT4IaVkbZrAlOymUKgvf/nHw8t3usIcx+fluASJvwyILaJXlxdx10YL6+erERAFebW1txKsx4iUtsLWYtQm2vbNmxCe8tNRBJ/GWzVgrbsv8fn/Y8KQQ/f7NIe3irNKi1ZCHLdUaX/Catr/JXW1WM16B4Tyv/VhbxPCkAhtim6lWC7cys8MfJ6v9VosJZh1K1gPvil+0u7sbPSmBrVCI5ruQp8GQHNvwpjrs1PaNb8AWZC9+OQg0rUFGo1EIBoNh1ICfi+NJ08DfNE1Ldu6o3q1vr/bkZE2NXYDZjkwvP/gNUmPs905CCELezhyHNybhrfMttTBa+gv29tOxglqd+DV+8WXLlqEVK1aMGODZ0IyFSzOmbSgDlCW+ZySp1lcAikqlQvfv3x+1rYNnEAfi2lItSygifohjs3ZggA8fPhy1V37w4IEA0J6RdoKQ48V6E9+50OjRo0ejeiA8w52Fw56OCDlWvuWNhbhdy8hIH3PIAnFw/O2b1hTKGt76NcspR2b6Kgxk06aNYwKEODh+nit75f692+TtgXq97gQG0tPTHcag+Q8BoMmYclzW8FgeCh3DcDC0Wm3YeyIMn4Ydosi3HYRl+Fxn1hrsTbkuV9irMS6nc2hHbnqBD5oCWSo5acqPGMShQwfDXomBuHi2wdoIyNYLExJUwj5IpML7I/x+ivyUk2UPUJKzgZGovr5OqMbu3OzvZQeQ35Ic7H0jXNqCatzT0yNUYy0ts86Enbr9iuFFspwvFaTFdlibnYWevPiHV1SQlyFedgJPGg88iRdyRzzynFlpcQvOnefirlpaI6wPwsnUiQps4KrMz5MpT36ceeKLzzfAoJkym4y3hSqXZpswPOy5YAvbtVjMtyEvyDMu9FxNFQvvP2VBvusSJVqZhk3yiWwmiSHeYG2JmoWgx+26BLOcuuqK+ICY68q5I4Z34cL5Ce/GSfV71/kQiHmurDsxC+zQgT3ctXnXZvgq8G8MDxr6M2d+RpOl06dPI9GHO0E2v3/ea3qX+zLxyyMHYguiIzOtmZJ893bx4oUn7nnS9rCrq2vYBpM9M213TEBbtKCOuzI03UmJ9mk1Gg26caNv0uBJIUJekKfIE9EUvR7KRE3z5EYnvAL34DDFaEi5Lv7vr1q1Et27d2/S4UkFefp8r4d4okaj/gXKmJKcFH0AO459BqdNfxIX+Pjx9qcOTuqNbW2tIRAZRnsKobuKqANYWDhtg7inPXfu7DODJ4XY2dkZ0kOz7fNLUQXv8Cf7tOIPozs6Op45vGGe2Noqrsr8h05RoObdW9iG2d2AvS8pSR8V4IZDDIpPt6ICt7Pq45ad0QGxdq63BResrfUrFK06evRzAWBRQd66qKnCxdM9wqervb1/RS3A69euDR3GLCmKnk9k+cJwBYOjZiaTSQhGoynk73CCcVLSDx6li0qAZcWF7dTTP742oVBWHEUAZ1eUnKTZkf+IgR7l98cE7TjSRBpme0tORgW8lctfjtlFj1guOxERERERERHRBPU/1iBg+5yQWfoAAAAASUVORK5CYII=';

  // src/pieces.ts
  // Map chessboard.js piece keys to inlined data URLs via rollup-url plugin
  const pieceMap = {
    bK,
    bQ,
    bR,
    bB,
    bN,
    bP,
    wK,
    wQ,
    wR,
    wB,
    wN,
    wP,
  };
  function bundledPieceTheme(name) {
    // chessboard.js calls pieceTheme with '{piece}.png' names like 'wK'
    return pieceMap[name] || '';
  }

  function init(root, fields, opts = {}) {
    const fen = fields.fen?.trim() || 'start';
    const sanSeq = JSON.parse(fields.sanJson || '[]');
    const engine = createEngine({ fen, sanSeq });
    const boardEl = root.querySelector('#board');
    const board = mountBoard(boardEl, {
      fen,
      pieceTheme: opts.pieceTheme ?? ((name) => bundledPieceTheme(name)),
      speeds: opts.speeds,
      onDrop: (source, target) => {
        if (source === target) return 'snapback';
        const res = engine.tryUserMove({ from: source, to: target });
        if (!res.correct) {
          const feedback = fb;
          feedback.flashWrong(res.expected?.from, res.expected?.to);
          scheduler.fail();
          // restore UI to engine FEN to guarantee snapback
          board.position(res.fen);
          return 'snapback';
        }
        fb.progress(engine.getStep(), engine.getTotal());
        fb.listPlayed(engine.getSeq(), engine.getStep());
        // completion?
        if (engine.getStep() === engine.getTotal()) {
          scheduler.pass();
        } else {
          // opponent reply with small delay
          if (typeof setTimeout === 'function') {
            const nextSAN = engine.getSeq()[engine.getStep()];
            setTimeout(() => {
              // engine-level auto-play for opponent: simulate expected move
              const exp = engine.expectedMove();
              if (exp?.from && exp?.to) {
                // force board to new fen via engine try (bypass correctness)
                // You can extend engine with an autoPlayExpected() if you prefer.
                const ChessCtor =
                  window.Chess || (window.chess && window.chess.Chess);
                const tmp = new ChessCtor(engine.getFen());
                tmp.move(nextSAN, { sloppy: true });
              }
            }, opts.delayMs ?? 450);
          }
        }
      },
    });
    const fb = createFeedback(root);
    const scheduler = createScheduler({ autoAnswer: opts.autoAnswer ?? true });
    // initial UI
    fb.progress(engine.getStep(), engine.getTotal());
    fb.listPlayed(engine.getSeq(), engine.getStep());
    return { engine, board, fb, scheduler };
  }
  // UMD global for Anki
  // @ts-ignore
  if (typeof window !== 'undefined') window.AnkiMoveTrainer = { init };

  exports.init = init;
});
